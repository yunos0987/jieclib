(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./string_lib/string_lib.txt -o ./string_lib/string_lib.xml -t omron
 * $ jiecc ./string_lib/string_lib.txt -o ./string_lib/string_lib.xml -t keyence
 *)

{#ifndef __STRING_LIB_TXT__}
{#define __STRING_LIB_TXT__}

{#define CHAR_MAX_BYTE 4}
{#define STRING string[STRING_MAX_SIZE]}

function charAt: string[CHAR_MAX_BYTE + 1]
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
		{doc: 1 origin.}
		p: dint := 1;
	end
	var_temp
		l: dint;
	end
	{st}
	l := uint_to_dint(len(self));
	if (1 <= p) and (p <= l) then
		charAt := mid(self, 1, dint_to_uint(p));
	else
		charAt := '';
	end_if;
	{end}
end

function asciiCharCodeAt: dint
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
		p: dint := 1;
	end
	var_temp
		c_x: string[CHAR_MAX_BYTE + 1];
		index: dint;
		ASCIIs: string[16#7f + 1] := (*'$00'*)
			'$01$02$03$04$05$06$07$08$09'
			'$0A$0B$0C$0D$0E$0F$10$11$12$13'
			'$14$15$16$17$18$19$1A$1B$1C$1D'
			'$1E$1F !"#$$%&$'()*+,-./0123456789:;<=>?'
			'@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\]^_'
			'`abcdefghijklmnopqrstuvwxyz{|}~$7F' constant;
	end
	{st}
    // note: Poor performance. Should be optimize.
	c_x := charAt(self, p);
	for index := 1 to 127 by 1 do
		if c_x = charAt(ASCIIs, index) then
			asciiCharCodeAt := index;
			return;
		end_if;
	end_for;
	asciiCharCodeAt := -1;
	{end}
end

function fromAsciiCharCode: string[CHAR_MAX_BYTE + 1]
	{#define CODE0 16#00}
	{#define CODE1 16#7f}
	_PROLOGUE_OF_FUNCTION_()
	var_input
		charcode: dint;
	end
{#if not (_KEYENCE)}
	var_temp constant
{#else}
	var_temp
{#endif}
		CODE2CHAR: array[CODE0..CODE1] of string[1 + 1] := [
			'$00', '$01', '$02', '$03', '$04', '$05', '$06', '$07', '$08', '$09', '$0A', '$0B', '$0C', '$0D', '$0E', '$0F',
			'$10', '$11', '$12', '$13', '$14', '$15', '$16', '$17', '$18', '$19', '$1A', '$1B', '$1C', '$1D', '$1E', '$1F',
			'$20', '$21', '$22', '$23', '$24', '$25', '$26', '$27', '$28', '$29', '$2A', '$2B', '$2C', '$2D', '$2E', '$2F',
			'$30', '$31', '$32', '$33', '$34', '$35', '$36', '$37', '$38', '$39', '$3A', '$3B', '$3C', '$3D', '$3E', '$3F',
			'$40', '$41', '$42', '$43', '$44', '$45', '$46', '$47', '$48', '$49', '$4A', '$4B', '$4C', '$4D', '$4E', '$4F',
			'$50', '$51', '$52', '$53', '$54', '$55', '$56', '$57', '$58', '$59', '$5A', '$5B', '$5C', '$5D', '$5E', '$5F',
			'$60', '$61', '$62', '$63', '$64', '$65', '$66', '$67', '$68', '$69', '$6A', '$6B', '$6C', '$6D', '$6E', '$6F',
			'$70', '$71', '$72', '$73', '$74', '$75', '$76', '$77', '$78', '$79', '$7A', '$7B', '$7C', '$7D', '$7E', '$7F',];
	end
	{st}
	if (CODE0 <= charcode) and (charcode <= CODE1) then
		fromAsciiCharCode := CODE2CHAR[charcode];
	else
		eno := false;
		fromAsciiCharCode := '';
	end_if;
	{end}
	{#undef CODE0}
	{#undef CODE1}
end

function lower: STRING
	{#define CHARCODE_A 16#41}
	{#define CHARCODE_Z 16#5a}
	{#define DIFF_CHARCODE_U2L 16#20}
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
	var_temp
		p, l: dint;
		c_x, d_x: string[CHAR_MAX_BYTE + 1];
		code: dint;
	end
	{st}
	lower := '';
	l := len(self);
	for p := 1 to l by 1 do
		c_x := charAt(self, p);
		code := asciiCharCodeAt(c_x, 1);
		if (CHARCODE_A <= code) and (code <= CHARCODE_Z) then
			d_x := fromAsciiCharCode(code + DIFF_CHARCODE_U2L);
			lower := concat(lower, d_x);
		else
			lower := concat(lower, c_x);
		end_if;
	end_for;
	{end}
	{#undef CHARCODE_A}
	{#undef CHARCODE_Z}
	{#undef DIFF_CHARCODE_U2L}
end
{#define toLowerCase lower}

function upper: STRING
	{#define CHARCODE_a 16#61}
	{#define CHARCODE_z 16#7a}
	{#define DIFF_CHARCODE_U2L 16#20}
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
	var_temp
		p, l: dint;
		c_x, d_x: string[CHAR_MAX_BYTE + 1];
		code: dint;
	end
	{st}
	upper := '';
	l := len(self);
	for p := 1 to l by 1 do
		c_x := charAt(self, p);
		code := asciiCharCodeAt(c_x, 1);
		if (CHARCODE_a <= code) and (code <= CHARCODE_z) then
			d_x := fromAsciiCharCode(code - DIFF_CHARCODE_U2L);
			upper := concat(upper, d_x);
		else
			upper := concat(upper, c_x);
		end_if;
	end_for;
	{end}
	{#undef CHARCODE_a}
	{#undef CHARCODE_z}
	{#undef DIFF_CHARCODE_U2L}
end
{#define toUpperCase upper}

function remove: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		{doc: 入力文字列}
		self: STRING;
		{doc: 削除文字列}
		del: STRING;
		{doc: 最大削除回数}
		count: dint := -1;
	end
	var_temp
		del_len: dint;
		c_x: dint;
		p, l: dint;
		h_str, t_str: STRING;
		r_str: STRING;
	end
	{st}
	del_len := len(del);
	t_str := self;
	l := len(t_str);
	c_x := count;
	while c_x <> 0 do
		p := find(t_str, del);
		if p = 0 then
			exit;
		end_if;
		// e.g. (t_str del)=(abcdef cd) --> p=3 h_str=ab, t_str=ef, l=2
		h_str := mid(t_str, dint_to_uint(p - 1), 1);
		l := l - (p + del_len) + 1;
		if l <> 0 then
			t_str := mid(t_str, dint_to_uint(l), dint_to_uint(p + del_len));
		else
			t_str := '';
		end_if;
		r_str := concat(r_str, h_str);
		c_x := c_x - 1;
	end_while;
	remove := concat(r_str, t_str);
	{end}
end

function reverse: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
	var_temp
		p: dint;
	end
	{st}
	reverse := '';
	for p := len(self) to 1 by -1 do
		reverse := concat(reverse, mid(self, 1, dint_to_uint(p)));
	end_for;
	{end}
end

function startswith: bool
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
		prefix: STRING;
	end
	var_temp
		m: dint;
	end
	{st}
	m := len(prefix);
	if m <> 0 then
		if uint_to_dint(len(self)) >= m then
			startswith := prefix = left(self, dint_to_uint(m));
		else
			startswith := false;
		end_if;
	else
		startswith := true;
	end_if;
	{end}
end

function endswith: bool
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
		suffix: STRING;
	end
	var_temp
		m: dint;
	end
	{st}
	m := len(suffix);
	if m <> 0 then
		if uint_to_dint(len(self)) >= m then
			endswith := suffix = right(self, dint_to_uint(m));
		else
			endswith := false;
		end_if;
	else
		endswith := true;
	end_if;
	{end}
end

function split: dint
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
		delimiter: STRING := '';
	end
	var_in_out
		outputs: array[*] of STRING;
	end
	var_temp
		rem: STRING;
		p: dint;
		l, m: dint;
		i_0, i_1, index: dint;
	end
	{st}
	i_0 := lower_bound(outputs, 1);
	i_1 := upper_bound(outputs, 1);
	l := len(self);
	m := len(delimiter);
	if m = 0 then
		for p := 1 to l by 1 do
			index := i_0 + p - 1;
			if index > i_1 then
				split := i_1 - i_0 + 1;
				return;
			end_if;
			outputs[index] := mid(self, 1, dint_to_uint(p));
		end_for;
		split := l;
		return;
	end_if;

	index := i_0;
	rem := self;
	while true do
		if index > i_1 then
			split := i_1 - i_0 + 1;
			return;
		end_if;
		p := find(rem, delimiter);
		if p <> 0 then
			if p <> 1 then
				outputs[index] := left(rem, dint_to_uint(p - 1));
			else
				// note: for keyence. error on left(x, 0).
				outputs[index] := '';
			end_if;
			l := l - p - m + 1;
			if l <> 0 then
				rem := mid(rem, dint_to_uint(l), dint_to_uint(p + m));
			else
				// note: for keyence. error on mid(x, 0, p).
				rem := '';
			end_if;
			index := index + 1;
		else
			outputs[index] := rem;
			split := index - i_0 + 1;
			return;
		end_if;
	end_while;
	{end}
end

{#if _KEYENCE}
{#define trim strip}
{#endif}
function trim: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
{#if not (_KEYENCE)}
	var_temp constant
{#else}
	var_temp
{#endif}
		WHITESPACES: array[4] of string[2] := [' ', '$t', '$r', '$n'];
	end
	var_temp
		l, i_0, i_1: dint;
		index, jndex: dint;
		c_x: string[2];
		found: bool;
	end
	{st}
	l := len(self);
	if l = 0 then
		trim := '';
		return;
	end_if;
	i_0 := 1;
	i_1 := l;

	for index := 1 to l by 1 do
		c_x := mid(self, 1, dint_to_uint(index));
		found := false;
		for jndex := 0 to 3 by 1 do
			if c_x = WHITESPACES[jndex] then
				i_0 := index + 1;
				found := true;
				exit;
			end_if;
		end_for;
		if not found then
			exit;
		end_if;
	end_for;

	if i_0 > l then
		trim := '';
		return;
	end_if;

	for index := l to i_0 by -1 do
		c_x := mid(self, 1, dint_to_uint(index));
		found := false;
		for jndex := 0 to 3 by 1 do
			if c_x = WHITESPACES[jndex] then
				i_1 := index - 1;
				found := true;
				exit;
			end_if;
		end_for;
		if not found then
			exit;
		end_if;
	end_for;

	trim := mid(self, dint_to_uint(i_1 - i_0 + 1), dint_to_uint(i_0));
	{end}
end

function ltrim: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
{#if not (_KEYENCE)}
	var_temp constant
{#else}
	var_temp
{#endif}
		WHITESPACES: array[4] of string[2] := [' ', '$t', '$r', '$n'];
	end
	var_temp
		l: dint;
		p: dint:= 1;
		index, jndex: dint;
		c_x: string[2];
		found: bool;
	end
	{st}
	l := len(self);
	if l = 0 then
		ltrim := '';
		return;
	end_if;

	for index := 1 to l by 1 do
		c_x := mid(self, 1, dint_to_uint(index));
		found := false;
		for jndex := 0 to 3 by 1 do
			if c_x = WHITESPACES[jndex] then
				p := index + 1;
				found := true;
				exit;
			end_if;
		end_for;
		if not found then
			exit;
		end_if;
	end_for;

	if p > l then
		ltrim := '';
		return;
	end_if;

	ltrim := mid(self, dint_to_uint(l - p + 1), dint_to_uint(p));
	{end}
end

function rtrim: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING;
	end
{#if not (_KEYENCE)}
	var_temp constant
{#else}
	var_temp
{#endif}
		WHITESPACES: array[4] of string[2] := [' ', '$t', '$r', '$n'];
	end
	var_temp
		l, p: dint;
		index, jndex: dint;
		c_x: string[2];
		found: bool;
	end
	{st}
	l := len(self);
	if l = 0 then
		rtrim := '';
		return;
	end_if;
	p := l;

	for index := l to 1 by -1 do
		c_x := mid(self, 1, dint_to_uint(index));
		found := false;
		for jndex := 0 to 3 by 1 do
			if c_x = WHITESPACES[jndex] then
				p := index - 1;
				found := true;
				exit;
			end_if;
		end_for;
		if not found then
			exit;
		end_if;
	end_for;

	if p < 1 then
		rtrim := '';
		return;
	end_if;

	rtrim := mid(self, dint_to_uint(p), 1);
	{end}
end

function join: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING := '';
	end
	var_in_out
		a: array[*] of STRING;
	end
	var_temp
		index, i_0, i_1: dint;
	end
	{st}
	i_0 := lower_bound(a, 1);
	i_1 := upper_bound(a, 1);
	join := a[i_0];
	for index := i_0 + 1 to i_1 by 1 do
		join := concat(join, self, a[index]);
	end_for;
	{end}
end

function substitute: STRING
	_PROLOGUE_OF_FUNCTION_()
	var_input
		self: STRING; // 入力文字列
		old: STRING; // 置換前文字列
		new: STRING; // 置換後文字列
		count: dint := -1; // 最大置換回数
	end
	var_temp
		old_len: dint;
		c_x: dint;
		p, l: dint;
		h_str, t_str: STRING;
	end
	{st}
	substitute := '';
	old_len := len(old);
	t_str := self;
	l := len(t_str);
	c_x := count;
	while c_x <> 0 do
		p := find(t_str, old);
		if p = 0 then
			exit;
		end_if;
		// e.g. abcdef cd p=3 h_str=ab,cd,t_str=ef
		h_str := mid(t_str, dint_to_uint(p - 1), 1);
		l := l - (p + old_len) + 1;
		t_str := mid(t_str, dint_to_uint(l), dint_to_uint(p + old_len));
		substitute := concat(substitute, h_str, new);
		c_x := c_x - 1;
	end_while;
	substitute := concat(substitute, t_str);
	{end}
end

{#endif}
