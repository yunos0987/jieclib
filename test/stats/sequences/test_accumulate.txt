(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./test/stats/sequences/test_accumulate.txt -I. -I./vendor/jiecunit/sys -I./vendor/jiecunit -D_TEST_ -o ./test/stats/sequences/test_accumulate.xml -t omron
 *)
{#include <jiecunit.txt>}
{#include <stats/sequences/accumulate.txt>}

{#ifdef _TEST_}
DEFINE_CONFIGURATION(
	_JIEC_TESTNAMES_LIST_(
		'test_stats_sum',
		'test_stats_sum_kahan',
		'test_stats_sum_and_count',
		'test_stats_sum_acc',
		'test_stats_kahan_sum_acc',
		'test_stats_mean_acc',
		'test_stats_welford_update',
		'test_stats_welford_finalize'
	)
)
{#endif}

{#define EPS 1.0e-9}

TEST_S(test_stats_sum)
	var
		x_1: array[0..4] of lreal := [3.0, 4.0, 10.0, 2.0, 1.0];
		x_2: array[0..3] of lreal := [1.5, -2.5, 3.0, -1.0];
		x_3: array[0..5] of lreal := [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
		x_4: array[0..9] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
		x_5: array[0..4] of lreal := [-5.0, -3.0, -1.0, -7.0, -2.0];
		x_6: array[0..9] of lreal := [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
		x_7: array[0..4] of lreal := [1000.0, 2000.0, 3000.0, 4000.0, 5000.0];
		x_8: array[0..0] of lreal := [42.0];
		x_9: array[0..1] of lreal := [15.5, 24.5];
		x_10: array[0..7] of lreal := [1.0, -1.0, 2.0, -2.0, 3.0, -3.0, 4.0, -4.0];
		x_11: array[0..4] of lreal := [1.0e-6, 2.0e-6, 3.0e-6, 4.0e-6, 5.0e-6];
		x_12: array[0..5] of lreal := [0.001, 1000.0, 0.01, 100.0, 0.1, 10.0];
	end
	{st}
	// Test 1: basic_positive
	EXPECT_NEAR(20.0, Stats_sum(x_1, -1), EPS);
	// Test 2: mixed_signs
	EXPECT_NEAR(1.0, Stats_sum(x_2, -1), EPS);
	// Test 3: all_zeros
	EXPECT_NEAR(0.0, Stats_sum(x_3, -1), EPS);
	// Test 4: sequence_1_to_10
	EXPECT_NEAR(55.0, Stats_sum(x_4, -1), EPS);
	// Test 5: all_negative
	EXPECT_NEAR(-18.0, Stats_sum(x_5, -1), EPS);
	// Test 6: decimal_sequence
	EXPECT_NEAR(5.5, Stats_sum(x_6, -1), EPS);
	// Test 7: large_numbers
	EXPECT_NEAR(15000.0, Stats_sum(x_7, -1), EPS);
	// Test 8: single_element
	EXPECT_NEAR(42.0, Stats_sum(x_8, -1), EPS);
	// Test 9: two_elements
	EXPECT_NEAR(40.0, Stats_sum(x_9, -1), EPS);
	// Test 10: alternating_signs
	EXPECT_NEAR(0.0, Stats_sum(x_10, -1), EPS);
	// Test 11: very_small_numbers
	EXPECT_NEAR(1.5e-5, Stats_sum(x_11, -1), EPS);
	// Test 12: mixed_magnitudes
	EXPECT_NEAR(1110.111, Stats_sum(x_12, -1), EPS);
	{end}
END_TEST_S


TEST_S(test_stats_sum_kahan)
	var
		x_1: array[0..4] of lreal := [3.0, 4.0, 10.0, 2.0, 1.0];
		x_2: array[0..3] of lreal := [1.5, -2.5, 3.0, -1.0];
		x_3: array[0..5] of lreal := [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
		x_4: array[0..9] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0];
		x_5: array[0..4] of lreal := [-5.0, -3.0, -1.0, -7.0, -2.0];
		x_6: array[0..9] of lreal := [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0];
		x_7: array[0..4] of lreal := [1000.0, 2000.0, 3000.0, 4000.0, 5000.0];
		x_8: array[0..0] of lreal := [42.0];
		x_9: array[0..1] of lreal := [15.5, 24.5];
		x_10: array[0..7] of lreal := [1.0, -1.0, 2.0, -2.0, 3.0, -3.0, 4.0, -4.0];
		x_11: array[0..4] of lreal := [1.0e-6, 2.0e-6, 3.0e-6, 4.0e-6, 5.0e-6];
		x_12: array[0..5] of lreal := [0.001, 1000.0, 0.01, 100.0, 0.1, 10.0];
	end
	{st}
	// Test 1: basic_positive
	EXPECT_NEAR(20.0, Stats_sum_kahan(x_1, -1), EPS);
	// Test 2: mixed_signs
	EXPECT_NEAR(1.0, Stats_sum_kahan(x_2, -1), EPS);
	// Test 3: all_zeros
	EXPECT_NEAR(0.0, Stats_sum_kahan(x_3, -1), EPS);
	// Test 4: sequence_1_to_10
	EXPECT_NEAR(55.0, Stats_sum_kahan(x_4, -1), EPS);
	// Test 5: all_negative
	EXPECT_NEAR(-18.0, Stats_sum_kahan(x_5, -1), EPS);
	// Test 6: decimal_sequence
	EXPECT_NEAR(5.5, Stats_sum_kahan(x_6, -1), EPS);
	// Test 7: large_numbers
	EXPECT_NEAR(15000.0, Stats_sum_kahan(x_7, -1), EPS);
	// Test 8: single_element
	EXPECT_NEAR(42.0, Stats_sum_kahan(x_8, -1), EPS);
	// Test 9: two_elements
	EXPECT_NEAR(40.0, Stats_sum_kahan(x_9, -1), EPS);
	// Test 10: alternating_signs
	EXPECT_NEAR(0.0, Stats_sum_kahan(x_10, -1), EPS);
	// Test 11: very_small_numbers
	EXPECT_NEAR(1.5e-5, Stats_sum_kahan(x_11, -1), EPS);
	// Test 12: mixed_magnitudes
	EXPECT_NEAR(1110.111, Stats_sum_kahan(x_12, -1), EPS);
	{end}
END_TEST_S

TEST_S(test_stats_sum_and_count)
	var
		x_5: array[0..4] of lreal := [3.0, 4.0, 10.0, 2.0, 1.0];
		x_6: array[0..5] of lreal := [0.0, 0.0, 0.0, 0.0, 0.0, 0.0];
		x_4: array[0..3] of lreal := [1.5, -2.5, 3.0, -1.0];
		s: lreal;
		n: dint;
	end
	{st}
	// basic
	s := Stats_sum_and_count(x:=x_5, count=>n);
	EXPECT_NEAR(20.0, s, EPS);
	EXPECT_EQ_INT32(5, n);
	// zeros
	s := Stats_sum_and_count(x:=x_6, count=>n);
	EXPECT_NEAR(0.0, s, EPS);
	EXPECT_EQ_INT32(6, n);
	// mixed signs
	s := Stats_sum_and_count(x:=x_4, count=>n);
	EXPECT_NEAR(1.0, s, EPS);
	EXPECT_EQ_INT32(4, n);
	{end}
END_TEST_S

TEST_S(test_stats_sum_acc)
	var
		acc: lreal := 0.0;
		x: array[0..4] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0];
		i: dint;
	end
	{st}
		// Accumulate sum incrementally
		for i := 0 to 4 do
			acc := Stats_sum_acc(acc:=acc, x:=x[i]);
		end_for;
		EXPECT_NEAR(15.0, acc, EPS);
	{end}
END_TEST_S

TEST_S(test_stats_kahan_sum_acc)
	var
		acc: lreal := 0.0;
		c: lreal := 0.0;
		x_basic: array[0..4] of lreal := [0.1, 0.2, 0.3, 0.4, 0.5];
		x_small_large: array[0..5] of lreal := [1.0e-10, 1.0, 1.0e-10, 1.0, 1.0e-10, 1.0];
		x_large: array[0..3] of lreal := [100.0, 200.0, 300.0, 400.0];
		i: dint;
	end
	{st}
		// Case 1: simple decimals
		acc := 0.0; c := 0.0;
		for i := 0 to 4 do
			acc := Stats_kahan_sum(acc:=acc, c:=c, x:=x_basic[i]);
		end_for;
		EXPECT_NEAR(1.5, acc, EPS);

		// Case 2: tiny + large mix; Kahan improves precision
		acc := 0.0; c := 0.0;
		for i := 0 to 5 do
			acc := Stats_kahan_sum(acc:=acc, c:=c, x:=x_small_large[i]);
		end_for;
		EXPECT_NEAR(3.0, acc, 1.0e-8);

		// Case 3: large values
		acc := 0.0; c := 0.0;
		for i := 0 to 3 do
			acc := Stats_kahan_sum(acc:=acc, c:=c, x:=x_large[i]);
		end_for;
		EXPECT_NEAR(1000.0, acc, EPS);
	{end}
END_TEST_S

TEST_S(test_stats_mean_acc)
	var
		acc_sum: lreal := 0.0;
		n: dint := 0;
		x_basic: array[0..4] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0];
		x_long: array[0..6] of lreal := [10.0, 20.0, 30.0, 40.0, 50.0, 60.0, 70.0];
		x_short: array[0..2] of lreal := [100.0, 200.0, 300.0];
		result: lreal;
		i: dint;
	end
	{st}
		// Case 1: basic mean
		acc_sum := 0.0; n := 0;
		for i := 0 to 4 do
			n := n + 1;
			acc_sum := Stats_sum_acc(acc:=acc_sum, x:=x_basic[i]);
		end_for;
		result := Stats_mean_acc(s:=acc_sum, n:=n);
		EXPECT_NEAR(3.0, result, EPS);

		// Case 2: longer sequence
		acc_sum := 0.0; n := 0;
		for i := 0 to 6 do
			n := n + 1;
			acc_sum := Stats_sum_acc(acc:=acc_sum, x:=x_long[i]);
		end_for;
		result := Stats_mean_acc(s:=acc_sum, n:=n);
		EXPECT_NEAR(40.0, result, EPS);

		// Case 3: short sequence
		acc_sum := 0.0; n := 0;
		for i := 0 to 2 do
			n := n + 1;
			acc_sum := Stats_sum_acc(acc:=acc_sum, x:=x_short[i]);
		end_for;
		result := Stats_mean_acc(s:=acc_sum, n:=n);
		EXPECT_NEAR(200.0, result, EPS);
	{end}
END_TEST_S

TEST_S(test_stats_welford_update)
	var
		m: lreal := 0.0;
		m2: lreal := 0.0;
		count: dint := 0;
		x: array[0..4] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0];
		x_basic: array[0..2] of lreal := [2.0, 4.0, 6.0];
		x_zeros: array[0..3] of lreal := [0.0, 0.0, 0.0, 0.0];
		x_identical: array[0..4] of lreal := [5.0, 5.0, 5.0, 5.0, 5.0];
		x_negative: array[0..3] of lreal := [-5.0, -3.0, -1.0, 1.0];
		x_large: array[0..2] of lreal := [1000.0, 2000.0, 3000.0];
		x_small: array[0..2] of lreal := [0.001, 0.002, 0.003];
		x_precision: array[0..3] of lreal := [1.1, 2.2, 3.3, 4.4];
		V: lreal;
		i: dint;
	end
	{st}
		// Test 1: Welford online algorithm for variance
		for i := 0 to 4 do
			count := count + 1;
			Stats_welford_update(x:=x[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_NEAR(3.0, m, EPS);
		EXPECT_NEAR(2.5, V, EPS);

		// Test 2: basic - Mean = 4.0
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 2 do
			count := count + 1;
			Stats_welford_update(x:=x_basic[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(4.0, m, EPS);
		// m2 = (2-4)^2 + (4-4)^2 + (6-4)^2 = 8
		EXPECT_NEAR(8.0, m2, EPS);

		// Test 3: zeros - All zeros: mean = 0, m2 = 0
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 3 do
			count := count + 1;
			Stats_welford_update(x:=x_zeros[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(0.0, m, EPS);
		EXPECT_NEAR(0.0, m2, EPS);

		// Test 4: identical - All identical: mean = 5, m2 = 0
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 4 do
			count := count + 1;
			Stats_welford_update(x:=x_identical[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(5.0, m, EPS);
		EXPECT_NEAR(0.0, m2, EPS);

		// Test 5: negative - Negative/positive mix: mean = -2.0
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 3 do
			count := count + 1;
			Stats_welford_update(x:=x_negative[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(-2.0, m, EPS);
		EXPECT_GT_LREAL(m2, 0.0);

		// Test 6: large - Large values: mean = 2000
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 2 do
			count := count + 1;
			Stats_welford_update(x:=x_large[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(2000.0, m, EPS);
		EXPECT_GT_LREAL(m2, 0.0);

		// Test 7: small - Small values: mean = 0.002
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 2 do
			count := count + 1;
			Stats_welford_update(x:=x_small[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(0.002, m, 1.0e-6);
		EXPECT_GT_LREAL(m2, 0.0);

		// Test 8: precision - Floating point values: mean = 2.75
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 3 do
			count := count + 1;
			Stats_welford_update(x:=x_precision[i], count:=count, m:=m, m2:=m2);
		end_for;
		EXPECT_NEAR(2.75, m, 0.01);
		EXPECT_GT_LREAL(m2, 0.0);
	{end}
END_TEST_S

TEST_S(test_stats_welford_finalize)
	var
		m: lreal := 0.0;
		m2: lreal := 0.0;
		count: dint := 0;
		x: array[0..4] of lreal := [1.0, 2.0, 3.0, 4.0, 5.0];
		x_three: array[0..2] of lreal := [1.0, 2.0, 3.0];
		x_single: lreal := 42.0;
		x_identical: array[0..3] of lreal := [7.0, 7.0, 7.0, 7.0];
		x_six: array[0..5] of lreal := [10.0, 20.0, 30.0, 40.0, 50.0, 60.0];
		x_mixed: array[0..5] of lreal := [-3.0, -1.0, 0.0, 1.0, 2.0, 4.0];
		x_prec: array[0..3] of lreal := [0.1, 0.2, 0.3, 0.4];
		V: lreal;
		var_sample: lreal;
		var_pop: lreal;
		i: dint;
	end
	{st}
		// Test 1: basic - Sample variance (ddof=1): 2.5
		for i := 0 to 4 do
			count := count + 1;
			Stats_welford_update(x:=x[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_NEAR(2.5, V, EPS);

		// Test 2: ddof - Compare sample (ddof=1) vs population (ddof=0)
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 2 do
			count := count + 1;
			Stats_welford_update(x:=x_three[i], count:=count, m:=m, m2:=m2);
		end_for;
		var_sample := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		var_pop := Stats_welford_finalize(m2:=m2, count:=count, ddof:=0);
		EXPECT_GT_LREAL(var_sample, var_pop);

		// Test 3: single - Single value: m2 = 0
		m := 0.0;
		m2 := 0.0;
		count := 1;
		Stats_welford_update(x:=x_single, count:=count, m:=m, m2:=m2);
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=0);
		EXPECT_NEAR(0.0, V, EPS);

		// Test 4: identical - Identical values: variance = 0
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 3 do
			count := count + 1;
			Stats_welford_update(x:=x_identical[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_NEAR(0.0, V, EPS);

		// Test 5: population - Population variance (ddof=0)
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 5 do
			count := count + 1;
			Stats_welford_update(x:=x_six[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=0);
		EXPECT_GT_LREAL(V, 0.0);

		// Test 6: sample - Sample variance (ddof=1) - unbiased
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 5 do
			count := count + 1;
			Stats_welford_update(x:=x_six[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_GT_LREAL(V, 0.0);

		// Test 7: mixed - Mixed negative/positive
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 5 do
			count := count + 1;
			Stats_welford_update(x:=x_mixed[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_GT_LREAL(V, 0.0);

		// Test 8: precision - Small precision floating point values
		m := 0.0;
		m2 := 0.0;
		count := 0;
		for i := 0 to 3 do
			count := count + 1;
			Stats_welford_update(x:=x_prec[i], count:=count, m:=m, m2:=m2);
		end_for;
		V := Stats_welford_finalize(m2:=m2, count:=count, ddof:=1);
		EXPECT_GT_LREAL(V, 0.0);
	{end}
END_TEST_S

{#undef EPS}
