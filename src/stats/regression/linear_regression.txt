(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/regression/linear_regression.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/regression/linear_regression.xml -t omron
 *)
{#ifndef __STATS_REGRESSION_LINEAR_REGRESSION_TXT__}
{#define __STATS_REGRESSION_LINEAR_REGRESSION_TXT__}

{#include <sys.txt>}
{#include <stats/descriptive/mean.txt>}
{#include <stats/descriptive/covariance.txt>}
{#include <stats/descriptive/variance.txt>}

(*{doc 単回帰結果}*)
type Stats_LinearRegressionResult :
	struct
		slope: lreal;
		intercept: lreal;
		r_squared: lreal;
		se: lreal;
	end_struct;
end_type

(*{doc 単回帰分析（y = slope * x + intercept）
最小二乗法でパラメータを推定
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout result 結果を格納する。
@error 入力値が不正な場合。}*)
function Stats_linear_regression
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 独立変数。}*)
		x: array[*] of lreal;
		(*{doc 従属変数。}*)
		y: array[*] of lreal;
	end
	var_in_out
		(*{doc 回帰結果。}*)
		result: Stats_LinearRegressionResult;
	end
	var_temp
		n_x, n_y, n, i: dint;
		mean_x, mean_y, cov_xy, var_x, slope, intercept: lreal;
		ss_total, ss_residual, residual, r_squared, se: lreal;
	end
	{st}
	n_x := Array_isRegular_lreal(x);
	if n_x = 0 then
		eno := false;
		return;
	end_if;
	n_y := Array_isRegular_lreal(y);
	if n_y = 0 then
		eno := false;
		return;
	end_if;
	if n_x <> n_y then
		eno := false;
		return;
	end_if;
	n := n_x;

	if n < 2 then
		eno := false;
		return;
	end_if;

	mean_x := Stats_mean(data:=x, n:=n, eno=>eno);
	if not eno then
		return;
	end_if;
	mean_y := Stats_mean(data:=y, n:=n, eno=>eno);
	if not eno then
		return;
	end_if;
	cov_xy := Stats_covariance(x:=x, y:=y, n:=n, ddof:=1, eno=>eno);
	if not eno then
		return;
	end_if;
	var_x := Stats_sample_variance(data:=x, n:=n, eno=>eno);
	if not eno then
		return;
	end_if;

	if var_x < 1e-15 then
		eno := false;
		return;
	end_if;

	// パラメータ推定
	slope := cov_xy / var_x;
	intercept := mean_y - slope * mean_x;

	// R^2 計算
	ss_total := 0.0;
	ss_residual := 0.0;
	for i := 0 to n - 1 do
		residual := y[i] - (slope * x[i] + intercept);
		ss_residual := ss_residual + residual * residual;
		ss_total := ss_total + (y[i] - mean_y) * (y[i] - mean_y);
	end_for;

	if ss_total > 1e-15 then
		r_squared := 1.0 - (ss_residual / ss_total);
	else
		r_squared := 0.0;
	end_if;

	// 標準誤差
	if n > 2 then
		se := sqrt(ss_residual / dint_to_lreal(n - 2));
	else
		se := 0.0;
	end_if;

	result.slope := slope;
	result.intercept := intercept;
	result.r_squared := r_squared;
	result.se := se;
	{end}
end

{#endif}
