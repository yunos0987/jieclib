(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/distributions/core/special_functions.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/distributions/core/special_functions.xml -t omron
 *)
{#ifndef __STATS_DISTRIBUTIONS_CORE_SPECIAL_FUNCTIONS_TXT__}
{#define __STATS_DISTRIBUTIONS_CORE_SPECIAL_FUNCTIONS_TXT__}

{#include <sys.txt>}

(*{doc 誤差関数。Error function。erf(x)
Abramowitz-Stegun 高精度近似。精度: 1e-12。
@input x 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_erf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
	end
	var_temp
		a1, a2, a3, a4, a5, p, t, abs_x: lreal;
		sign, erf_val, x2, series: lreal;
	end
	{st}
		// 符号を保持し、絶対値で作業
		if x < 0.0 then
			sign := -1.0;
			abs_x := -x;
		else
			sign := 1.0;
			abs_x := x;
		end_if;

		if abs_x = 0.0 then
			Stats_erf := 0.0;
			return;
		end_if;

		if abs_x < 3.5 then
			// 高精度 Abramowitz-Stegun 近似 (7.1.26)
			a1 := 0.254829592;
			a2 := -0.284496736;
			a3 := 1.421413741;
			a4 := -1.453152027;
			a5 := 1.061405429;
			p := 0.3275911;

			t := 1.0 / (1.0 + p * abs_x);
			erf_val := 1.0 - (((((a5 * t + a4) * t + a3) * t + a2) * t + a1) * t) * exp(-abs_x * abs_x);
		else
			// 大きな x 値に対する漸近近似
			x2 := abs_x * abs_x;
			series := 1.0 / (abs_x * sqrt(3.14159265358979323846));
			series := series * exp(-x2);
			series := series * (1.0 - 1.0 / (2.0 * x2) + 3.0 / (4.0 * x2 * x2));
			erf_val := 1.0 - series;
		end_if;

		Stats_erf := sign * erf_val;
	{end}
end

(*{doc 補誤差関数 erfc(x) = 1 - erf(x)。高精度実装。
@input x 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_erfc: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
	end
	{st}
		if x = 0.0 then
			Stats_erfc := 1.0;
			return;
		end_if;

		Stats_erfc := 1.0 - Stats_erf(x:=x);
	{end}
end

(*{doc ガンマ関数 Gamma(x)。Lanczos近似、x > 0。
@input x 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_gamma: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
	end
	var_temp
		result, work_x, sin_val, gamma_complement: lreal;
		z, sum_val, base, pi: lreal;
		g, c0, c1, c2, c3, c4, c5, c6: lreal;
	end
	{st}
		if x <= 0.0 then
			eno := false;
			Stats_gamma := 0.0;
			return;
		end_if;

		pi := 3.14159265358979323846;

		// Lanczos coefficients for g=7
		g := 7.0;
		c0 := 0.99999999999980993;
		c1 := 676.5203681218851;
		c2 := -1259.1392167224028;
		c3 := 771.32342877765313;
		c4 := -176.61502916214059;
		c5 := 12.507343278686905;
		c6 := -0.13857109526572012;

		if x < 0.5 then
			// 対称性: Gamma(x) = pi / (sin(pi*x) * Gamma(1-x)) を非再帰で計算
			work_x := 1.0 - x;

			// work_x (= 1-x) に対するガンマ関数をLanczos近似で計算
			z := work_x - 1.0;
			sum_val := c0 + c1/(z+1.0) + c2/(z+2.0) + c3/(z+3.0) + c4/(z+4.0) + c5/(z+5.0) + c6/(z+6.0);
			base := z + g + 0.5;
			gamma_complement := sqrt(2.0 * pi) * (base ** (z + 0.5)) * exp(-base) * sum_val;

			// 対称性公式を適用
			sin_val := sin(pi * x);
			if abs(sin_val) < 1.0e-15 then
				eno := false;
				Stats_gamma := 0.0;
				return;
			end_if;

			Stats_gamma := pi / (sin_val * gamma_complement);
			return;
		end_if;

		// x >= 0.5 向け Lanczos近似
		z := x - 1.0;
		sum_val := c0 + c1/(z+1.0) + c2/(z+2.0) + c3/(z+3.0) + c4/(z+4.0) + c5/(z+5.0) + c6/(z+6.0);
		base := z + g + 0.5;

		Stats_gamma := sqrt(2.0 * pi) * (base ** (z + 0.5)) * exp(-base) * sum_val;
	{end}
end

(*{doc 自然対数ガンマ関数 lgamma(x) = ln(Gamma(x))。x > 0。
@input x 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_lgamma: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
	end
	var_temp
		result, work_x, sin_val, lgamma_complement: lreal;
		z, sum_val, base, pi: lreal;
		g, c0, c1, c2, c3, c4, c5, c6: lreal;
	end
	{st}
		if x <= 0.0 then
			eno := false;
			Stats_lgamma := 0.0;
			return;
		end_if;

		pi := 3.14159265358979323846;

		// Lanczos coefficients for g=7
		g := 7.0;
		c0 := 0.99999999999980993;
		c1 := 676.5203681218851;
		c2 := -1259.1392167224028;
		c3 := 771.32342877765313;
		c4 := -176.61502916214059;
		c5 := 12.507343278686905;
		c6 := -0.13857109526572012;

		if x < 0.5 then
			// 対称性: ln(Gamma(x)) = ln(pi) - ln(sin(pi*x)) - ln(Gamma(1-x))
			work_x := 1.0 - x;  // work_x の初期化
			// work_x (= 1-x) に対する ln(Gamma) をLanczos近似で直接計算
			z := work_x - 1.0;
			sum_val := c0 + c1/(z+1.0) + c2/(z+2.0) + c3/(z+3.0) + c4/(z+4.0) + c5/(z+5.0) + c6/(z+6.0);
			base := z + g + 0.5;
			lgamma_complement := ln(sqrt(2.0 * pi)) + (z + 0.5) * ln(base) - base + ln(sum_val);

			// 対称性公式を適用
			sin_val := sin(pi * x);
			if abs(sin_val) < 1.0e-15 then
				eno := false;
				Stats_lgamma := 0.0;
				return;
			end_if;

			Stats_lgamma := ln(pi) - ln(abs(sin_val)) - lgamma_complement;
			return;
		end_if;

		// x >= 0.5 向け Lanczos近似でln(Gamma)を直接計算
		z := x - 1.0;
		sum_val := c0 + c1/(z+1.0) + c2/(z+2.0) + c3/(z+3.0) + c4/(z+4.0) + c5/(z+5.0) + c6/(z+6.0);
		base := z + g + 0.5;

		Stats_lgamma := ln(sqrt(2.0 * pi)) + (z + 0.5) * ln(base) - base + ln(sum_val);
	{end}
end

(*{doc 正規化下側不完全ガンマ関数 P(a,z) - gammainc(a,z)
P(a,z) = (1/Gamma(a)) * integral_0^z t^(a-1) * exp(-t) dt
シリーズ展開により計算。z < a+1 の場合に使用。
@input a 入力値。
@input z 入力値。
@input gln 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_gammainc: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc パラメータ。}*)
		a: lreal;
		(*{doc 入力値。}*)
		z: lreal;
		(*{doc 対数ガンマ関数値。}*)
		gln: lreal;
	end
	var_temp
		sum_val, ap, del, term: lreal;
		i: dint;
	end
	{st}
		// boundary: z=0 -> P=0
		if z = 0.0 then
			Stats_gammainc := 0.0;
			return;
		end_if;
		if z < 0.0 then
			eno := false;
			Stats_gammainc := 0.0;
			return;
		end_if;

		ap := a;
		del := 1.0 / a;
		sum_val := del;

	for i := 1 to 200 do
		ap := ap + 1.0;
		del := del * z / ap;
		sum_val := sum_val + del;

		if abs(del) < abs(sum_val) * 1.0e-15 then
			exit;
		end_if;
	end_for;

	// P(a,z) = sum * exp(-z + a*ln(z) - gln)
	Stats_gammainc := sum_val * exp(-z + a * ln(z) - gln);
	if Stats_gammainc < 0.0 then Stats_gammainc := 0.0; end_if;
	if Stats_gammainc > 1.0 then Stats_gammainc := 1.0; end_if;
	{end}
end

(*{doc 正規化上側不完全ガンマ関数 Q(a,z) - gammaincc(a,z)
Q(a,z) = (1/Gamma(a)) * integral_z^infinity t^(a-1) * exp(-t) dt
連分率展開により計算。z >= a+1 の場合に使用。
@input a 入力値。
@input z 入力値。
@input gln 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_gammaincc: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc パラメータ。}*)
		a: lreal;
		(*{doc 入力値。}*)
		z: lreal;
		(*{doc 対数ガンマ関数値。}*)
		gln: lreal;
	end
	var_temp
		i0, i1, an, b, c, d, del, h: lreal;
		i: dint;
	end
	{st}
		// boundary: z=0 -> Q=1
		if z = 0.0 then
			Stats_gammaincc := 1.0;
			return;
		end_if;
		(* 連分率展開
		   Q(a,z) = exp(-z + a*ln(z) - gln) * cf *)

		b := z + 1.0 - a;
		c := 1.0 / 1.0e-30;
		d := 1.0 / b;
		h := d;

		for i := 1 to 200 do
			an := dint_to_lreal(-i) * (dint_to_lreal(i) - a);
			b := b + 2.0;
			d := an * d + b;
			if abs(d) < 1.0e-30 then d := 1.0e-30; end_if;
			c := b + an / c;
			if abs(c) < 1.0e-30 then c := 1.0e-30; end_if;
			d := 1.0 / d;
			del := d * c;
			h := h * del;

			if abs(del - 1.0) < 1.0e-15 then
				exit;
			end_if;
		end_for;

		// Q(a,z) = h * exp(-z + a*ln(z) - gln)
		Stats_gammaincc := h * exp(-z + a * ln(z) - gln);
		if Stats_gammaincc < 0.0 then Stats_gammaincc := 0.0; end_if;
		if Stats_gammaincc > 1.0 then Stats_gammaincc := 1.0; end_if;
	{end}
end

(*{doc ベータ関数 Beta(a, b) = Gamma(a)*Gamma(b)/Gamma(a+b)。a,b > 0。
@input a 入力値。
@input b 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_beta: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc パラメータ a。}*)
		a: lreal;
		(*{doc パラメータ b。}*)
		b: lreal;
	end
	var_temp ga, gb, gab: lreal; end
	{st}
		if a <= 0.0 or b <= 0.0 then
			eno := false;
			Stats_beta := 0.0;
			return;
		end_if;
		ga := Stats_gamma(x:=a);
		gb := Stats_gamma(x:=b);
		gab := Stats_gamma(x:=a + b);
		if gab <= 0.0 then
			eno := false;
			Stats_beta := 0.0;
			return;
		end_if;
		Stats_beta := (ga * gb) / gab;
	{end}
end

(*{doc 正規化不完全ベータ関数 Beta_incomplete(x, a, b)
x の範囲は 0 <= x <= 1、a > 0、b > 0
@input x 入力値。
@input a 入力値。
@input b 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_beta_incomplete: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値 (0 <= x <= 1)。}*)
		x: lreal;
		(*{doc パラメータ a。}*)
		a: lreal;
		(*{doc パラメータ b。}*)
		b: lreal;
	end
	var_temp
		bt, result: lreal;
		qab, qap, qam, c, d, h, m2: lreal;
		aa: lreal;
		m: dint;
	end
	{st}
		if x < 0.0 or x > 1.0 or a <= 0.0 or b <= 0.0 then
			eno := false;
			Stats_beta_incomplete := 0.0;
			return;
		end_if;

		// 特殊ケース
		if x = 0.0 then
			Stats_beta_incomplete := 0.0;
			return;
		end_if;
		if x = 1.0 then
			Stats_beta_incomplete := 1.0;
			return;
		end_if;

		// 前因子を計算
		bt := exp(Stats_lgamma(x:=a + b) - Stats_lgamma(x:=a) - Stats_lgamma(x:=b) + a * ln(x) + b * ln(1.0 - x));

		if x < (a + 1.0) / (a + b + 2.0) then
			// 直接計算
			result := bt * Stats_beta_continued_fraction(x:=x, a:=a, b:=b) / a;
			Stats_beta_incomplete := result;
		else
			// 補完を使用
			result := 1.0 - bt * Stats_beta_continued_fraction(x:=1.0 - x, a:=b, b:=a) / b;
			Stats_beta_incomplete := result;
		end_if;
	{end}
end

(*{doc ベータ関数の連分率展開による計算補助関数
@input x 入力値。
@input a 入力値。
@input b 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_beta_continued_fraction: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値 (0 <= x <= 1)。}*)
		x: lreal;
		(*{doc パラメータ a。}*)
		a: lreal;
		(*{doc パラメータ b。}*)
		b: lreal;
	end
	var_temp
		qab, qap, qam, c, d, h, m2: lreal;
		aa: lreal;
		m: dint;
	end
	{st}
		qab := a + b;
		qap := a + 1.0;
		qam := a - 1.0;
		c := 1.0;
		d := 1.0 - qab * x / qap;
		if abs(d) < 1.0e-15 then d := 1.0e-15; end_if;
		d := 1.0 / d;
		h := d;

		for m := 1 to 100 do
			m2 := 2 * m;

			// 偶数ステップ
			aa := m * (b - m) * x / ((qam + m2) * (a + m2));
			d := 1.0 + aa * d;
			if abs(d) < 1.0e-15 then d := 1.0e-15; end_if;
			c := 1.0 + aa / c;
			if abs(c) < 1.0e-15 then c := 1.0e-15; end_if;
			d := 1.0 / d;
			h := h * d * c;

			// 奇数ステップ
			aa := -(a + m) * (qab + m) * x / ((a + m2) * (qap + m2));
			d := 1.0 + aa * d;
			if abs(d) < 1.0e-15 then d := 1.0e-15; end_if;
			c := 1.0 + aa / c;
			if abs(c) < 1.0e-15 then c := 1.0e-15; end_if;
			d := 1.0 / d;
			h := h * d * c;

			// 収束判定
			if abs(d * c - 1.0) < 1.0e-15 then exit; end_if;
		end_for;

		Stats_beta_continued_fraction := h;
	{end}
end

{#endif}

