(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/sequences/accumulate.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/sequences/accumulate.xml -t omron
 *)
{#ifndef __STATS_ACCUMULATE_TXT__}
{#define __STATS_ACCUMULATE_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <array/copy.txt>}

(*{doc 合計 (単純加算)
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sum: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n: dint;
		i: dint;
		s: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(x);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	s := 0.0;
	for i := 0 to actual_n - 1 do
		s := s + x[i];
	end_for;
	Stats_sum := s;
	{end}
end

(*{doc 合計 (Kahan補償付き)
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sum_kahan: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
	end
	var_input
		(*{doc 先頭 n 個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n, i: dint;
		s, c, y, t: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(x);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	s := 0.0;
	c := 0.0;
	for i := 0 to actual_n - 1 do
		y := x[i] - c;
		t := s + y;
		c := (t - s) - y;
		s := t;
	end_for;

	Stats_sum_kahan := s;
	{end}
end

(*{doc 合計と要素数を同時に計算
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@output count 出力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sum_and_count: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
	end
	var_output
		(*{doc 要素数。}*)
		count: dint;
	end
	var_temp
		i: dint;
		s: lreal;
	end
	{st}
	count := Array_isRegular_lreal(x);
	if count = 0 then
		eno := false;
		return;
	end_if;

	s := 0.0;
	for i := 0 to count - 1 do
		s := s + x[i];
	end_for;
	Stats_sum_and_count := s;
	{end}
end

(*{doc 逐次和 (単純加算の別名)
@input acc 入力値。
@input x 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sum_acc: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 累積値。}*)
		acc: lreal;
		(*{doc 入力値。}*)
		x: lreal;
	end
	{st}
	Stats_sum_acc := acc + x;
	{end}
end

(*{doc 逐次和 (Kahan/Neumaier補償付き)
@input x 入力値。
@inout acc 入力値。
@inout c 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_kahan_sum: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
	end
	var_in_out
		(*{doc 累積値。}*)
		acc: lreal;
		(*{doc 補正値。}*)
		c: lreal;
	end
	var_temp
		y, t: lreal;
	end
	{st}
	y := x - c;
	t := acc + y;
	c := (t - acc) - y;
	acc := t;
	Stats_kahan_sum := acc;
	{end}
end

(*{doc オンライン平均（逐次更新）
@input s 入力値。
@input n 先頭n個を使用する。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_mean_acc: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		s: lreal;
		(*{doc 先頭 n 個を使用する。}*)
		n: dint;
	end
	{st}
	if n <= 0 then
		eno := false;
		return;
	end_if;
	Stats_mean_acc := s / dint_to_lreal(n);
	{end}
end

(*{doc Welford法のオンライン分散更新用状態}*)
type Stats_welford_state :
	struct
		n: dint;		// 処理済みサンプル数
		mean: lreal;	// 現在の平均
		M2: lreal;	  // 二乗偏差の累積
	end_struct;
end_type

(*{doc Welford更新: 1サンプル x を状態に反映
@input x 入力値。
@input count 入力値。
@inout m 入力値。
@inout m2 入力値。
@error 入力値が不正な場合。}*)
function Stats_welford_update
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: lreal;
		(*{doc 事象数。}*)
		count: dint;
	end
	var_in_out
		(*{doc 現在の平均値}*)
		m: lreal;
		(*{doc 二乗偏差の累積}*)
		m2: lreal;
	end
	var_temp
		delta1: lreal;
		delta2: lreal;
	end
	{st}
	if count <= 0 then
		eno := false;
		return;
	end_if;
	delta1 := x - m;
	m := m + (delta1 / dint_to_lreal(count));
	delta2 := x - m;
	m2 := m2 + delta1 * delta2;
	{end}
end

(*{doc Welford状態から分散を算出
@input m2 入力値。
@input count 入力値。
@input ddof 自由度補正。
  デフォルト値: 0
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_welford_finalize: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 事象数。}*)
		m2: lreal;
		(*{doc 事象数。}*)
		count: dint;
		(*{doc 自由度補正。}*)
		ddof: dint := 0;
	end
	var_temp
		den: dint;
	end
	{st}
	den := count - ddof;
	if den <= 0 then
		eno := false;
		return;
	end_if;
	Stats_welford_finalize := m2 / dint_to_lreal(den);
	{end}
end

{#endif}
