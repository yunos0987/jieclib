(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/sequences/sort_select.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/sequences/sort_select.xml -t omron
 *)
{#ifndef __STATS_SEQUENCES_SORT_SELECT_TXT__}
{#define __STATS_SEQUENCES_SORT_SELECT_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}

(*{doc data を昇順でソートしたコピーをsortedに返す
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@inout sorted ソート済みデータを格納する配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力値が不正な場合。}*)
function Stats_sorted_copy
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_in_out
		(*{doc ソート済みのデータをコピーして格納する配列。}*)
		sorted: array[*] of lreal;
	end
	var_temp
		actual_n: dint;
	end
	{st}
	actual_n := Array_copy_x_lreal(src:=data, src_index:=0, dst:=sorted, dst_index:=0, n:=n, eno=>eno);
	if not eno then
		return;
	end_if;
	Array_quicksort_n_lreal(self:=sorted, ascending:=true, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;
	{end}
end

(*{doc data 内で k 番目(0-origin)の要素値を返す（非破壊的、work配列を使用、メディアン・オブ・スリーでピボット選択）
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input k 取得する順位(0-origin)。
@inout work 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_select_kth: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
		(*{doc 取得する順位(0-origin)。}*)
		k: dint;
	end
	var_in_out
		(*{doc 元データと同じサイズ以上の作業配列。}*)
		work: array[*] of lreal;
	end
	var_temp
		actual_n: dint;
		nwork: dint;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;
	nwork := Array_isRegular_lreal(work);
	if (nwork = 0) or (nwork < actual_n) then
		eno := false;
		return;
	end_if;
	if (k < 0) or (k >= actual_n) then
		eno := false;
		return;
	end_if;

	Array_copy_x_lreal(src:=data, src_index:=0, dst:=work, dst_index:=0, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;
	Array_quicksort_n_lreal(self:=work, ascending:=true, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;

	Stats_select_kth := work[k];
	{end}
end

{#endif}
