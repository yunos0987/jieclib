(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/moments/standardized_moments.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/moments/standardized_moments.xml -t omron
 *)
{#ifndef __STATS_MOMENTS_STANDARDIZED_MOMENTS_TXT__}
{#define __STATS_MOMENTS_STANDARDIZED_MOMENTS_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <stats/descriptive/variance.txt>}
{#include <stats/moments/central_moments.txt>}

(*{doc 標準化モーメント μ_k / σ^k。σ は母標準偏差。
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭 n 個を使用する。
  デフォルト値: -1
@input k 次数。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_standardized_moment: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭 n 個を使用する。}*)
		n: dint := -1;
		(*{doc 次数。}*)
		k: dint;
	end
	var_temp
		actual_n: dint;
		(*{doc 分散。}*)
		v: lreal;
		sigma: lreal;
		sigma_k: lreal;
		cm: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;
	v := Stats_variance(data:=data, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;
	if v = 0.0 then
		eno := false;
		return;
	end_if;
	sigma := sqrt(v);
	sigma_k := sigma ** k;
	cm := Stats_central_moment(data:=data, k:=k, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;
	Stats_standardized_moment := cm / sigma_k;
	{end}
end

(*{doc 配列から歪度を計算 = 標準化3次モーメント
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function private_Stats_skewness_from_data: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	private_Stats_skewness_from_data := Stats_standardized_moment(data:=data, k:=3, n:=n, eno=>eno);
	{end}
end

(*{doc モーメント値から歪度を計算
m2: 2次中心モーメント（分散）、m3: 3次中心モーメント
歪度 = m3 / m2^(3/2)
@input m2 入力値。
@input m3 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_skewness_from_moments: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		m2, m3: lreal;
	end
	{st}
	if m2 <= 0.0 then
		eno := false;
		return;
	end_if;
	Stats_skewness_from_moments := m3 / (m2 ** (3.0 / 2));
	{end}
end

(*{doc 配列から尖度を計算 = 標準化4次モーメント - 3
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function private_Stats_kurtosis_from_data: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	private_Stats_kurtosis_from_data := Stats_standardized_moment(data:=data, k:=4, n:=n, eno=>eno) - 3.0;
	{end}
end

(*{doc モーメント値から尖度を計算
m2: 2次中心モーメント（分散）、m4: 4次中心モーメント
fisher=true: Fisher尖度/過剰尖度（正規分布で0）、fisher=false: Pearson尖度（正規分布で3）
@input m2 入力値。
@input m4 入力値。
@input fisher 入力値。
	デフォルト値: true
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_kurtosis_from_moments: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 2次中心モーメント（分散）。}*)
		m2: lreal;
		(*{doc 4次中心モーメント。}*)
		m4: lreal;
		(*{doc Fisherの定義を使用するかどうか。}*)
		fisher: bool := true;
	end
	{st}
	if m2 <= 0.0 then
		eno := false;
		return;
	end_if;
	if fisher then
		Stats_kurtosis_from_moments := m4 / (m2 * m2) - 3.0;
	else
		Stats_kurtosis_from_moments := m4 / (m2 * m2);
	end_if;
	{end}
end

{#endif}

