(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/descriptive/mean.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/descriptive/mean.xml -t omron
 *)
{#ifndef __STATS_MEAN_TXT__}
{#define __STATS_MEAN_TXT__}

{#include <sys.txt>}
{#include <math/floor.txt>}
{#include <array/array.txt>}
{#include <stats/sequences/accumulate.txt>}
{#include <stats/sequences/sort_select.txt>}

(*{doc 平均計算 (sum / n)
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n: dint;
		s: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;
	s := Stats_sum(x:=data, n:=actual_n, eno=>eno);
	if not eno then
		return;
	end_if;

	Stats_mean := s / dint_to_lreal(actual_n);
	{end}
end

(*{doc 加重平均計算 (sum(x*w) / sum(w))
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@inout w 重みを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_weighted_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_in_out
		(*{doc 重みを含む配列。}*)
		w: array[*] of lreal;
	end
	var_temp
		ndata, nw: dint;
		actual_n: dint;
		len_x, len_w: dint;
		i: dint;
		sum_xw: lreal;
		sum_w: lreal;
	end
	{st}
	ndata := Array_isRegular_lreal(data);
	if (ndata = 0) or (n > ndata) then
		eno := false;
		return;
	end_if;
	nw := Array_isRegular_lreal(w);
	if (nw = 0) or (n > nw) then
		eno := false;
		return;
	end_if;
	if n < 0 then
		if ndata <> nw then
			eno := false;
			return;
		end_if;
		actual_n := ndata;
	else
		actual_n := n;
	end_if;

	sum_xw := 0.0;
	sum_w := 0.0;
	for i := 0 to actual_n - 1 do
		sum_xw := sum_xw + data[i] * w[i];
		sum_w := sum_w + w[i];
	end_for;
	Stats_weighted_mean := sum_xw / sum_w;
	{end}
end

(*{doc トリム平均 端から proportion 割合を除外して平均
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input proportion 端から除外する割合。
  デフォルト値: 0.1
@inout work 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_trimmed_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_input
		(*{doc 端から除外する割合。}*)
		proportion: lreal := 0.1; // 0..0.5 未満
	end
	var_in_out
		(*{doc 作業配列。}*)
		work: array[*] of lreal;
	end
	var_temp
		actual_n: dint;
		nwork: dint;
		m: dint;
		i: dint;
		acc: lreal;
		cnt: dint;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	nwork := Array_isRegular_lreal(work);
	if (nwork = 0) or (nwork < actual_n) then
		eno := false;
		return;
	end_if;

	if (proportion < 0.0) or (proportion >= 0.5) then
		eno := false;
		return;
	end_if;

	Array_copy_x_lreal(src:=data, src_index:=0, dst:=work, dst_index:=0, n:=actual_n);
	Array_quicksort_n_lreal(self:=work, n:=actual_n, ascending:=true);
	m := lreal_to_dint(Math_floor(x:=dint_to_lreal(actual_n) * proportion));
	if (2 * m) >= actual_n then
		eno := false;
		return;
	end_if;

	acc := 0.0;
	cnt := 0;
	for i := m to (actual_n - m - 1) do
		acc := acc + work[i];
		cnt := cnt + 1;
	end_for;
	Stats_trimmed_mean := acc / dint_to_lreal(cnt);
	{end}
end

(*{doc ウィンザー平均 端の proportion 割合を端値で置換して平均
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input proportion 端から置換する割合。
  デフォルト値: 0.1
@inout work 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_winsorized_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
		(*{doc 端から置換する割合。}*)
		proportion: lreal := 0.1;
	end
	var_in_out
		(*{doc 作業配列。}*)
		work: array[*] of lreal;
	end
	var_temp
		actual_n: dint;
		nwork: dint;
		m: dint;
		i: dint;
		acc: lreal;
		lowv, highv: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;
	nwork := Array_isRegular_lreal(work);
	if (nwork = 0) or (nwork < actual_n) then
		eno := false;
		return;
	end_if;

	if (proportion < 0.0) or (proportion >= 0.5) then
		eno := false;
		return;
	end_if;

	Array_copy_x_lreal(src:=data, src_index:=0, dst:=work, dst_index:=0, n:=actual_n);
	Array_quicksort_n_lreal(self:=work, n:=actual_n, ascending:=true);

	m := lreal_to_dint(Math_floor(x:=dint_to_lreal(actual_n) * proportion));
	lowv := work[m];
	highv := work[actual_n - m - 1];

	acc := 0.0;
	for i := 0 to actual_n - 1 do
		if i < m then
			acc := acc + lowv;
		elsif i >= actual_n - m then
			acc := acc + highv;
		else
			acc := acc + work[i];
		end_if;
	end_for;

	Stats_winsorized_mean := acc / dint_to_lreal(actual_n);
	{end}
end

(*{doc 指定軸方向の平均計算 (axis=1: 行方向, axis=2: 列方向)
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input axis 軸方向。
  デフォルト値: 1
@inout result 結果を格納する配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力値が不正な場合。}*)
function Stats_mean_axis
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*, *] of lreal;
	end
	var_input
		(*{doc 軸方向 (1=行, 2=列)。}*)
		axis: dint := 1;
	end
	var_in_out
		(*{doc 結果を格納する配列。}*)
		result: array[*] of lreal;
	end
	var_temp
		nrows, ncols: dint;
		nresult: dint;
		i, j: dint;
		s: lreal;
	end
	{st}
	nrows := Array_size(data);
	ncols := upper_bound(data, 2) - lower_bound(data, 2) + 1;

	nresult := Array_isRegular_lreal(result);
	if nresult = 0 then
		eno := false;
		return;
	end_if;

	if axis = 1 then
		if nresult > ncols then
			eno := false;
			return;
		end_if;

		for j := 0 to ncols - 1 do
			s := 0.0;
			for i := 0 to nrows - 1 do
				s := s + data[i, j];
			end_for;
			result[j] := s / dint_to_lreal(nrows);
		end_for;
	elsif axis = 2 then
		if nresult > nrows then
			eno := false;
			return;
		end_if;

		for i := 0 to nrows - 1 do
			s := 0.0;
			for j := 0 to ncols - 1 do
				s := s + data[i, j];
			end_for;
			result[i] := s / dint_to_lreal(ncols);
		end_for;
	else
		eno := false;
		return;
	end_if;
	{end}
end

(*{doc Kahan補償アルゴリズムを使用した高精度平均
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_mean_kahan: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n: dint;
		s: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	s := Stats_sum_kahan(x:=data, n:=actual_n, eno=>eno);
	Stats_mean_kahan := s / dint_to_lreal(actual_n);
	{end}
end

{#endif}

