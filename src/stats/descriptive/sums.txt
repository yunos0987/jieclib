(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/descriptive/sums.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/descriptive/sums.xml -t omron
 *)
{#ifndef __STATS_DESCRIPTIVE_SUMS_TXT__}
{#define __STATS_DESCRIPTIVE_SUMS_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <stats/sequences/accumulate.txt>}

(*{doc 総和
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sums_sum: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	Stats_sums_sum := Stats_sum(x:=data, n:=n, eno=>eno);
	{end}
end

(*{doc 高精度総和 (Kahan補償)
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sums_fsum: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	Stats_sums_fsum := Stats_sum_kahan(x:=data, n:=n, eno=>eno);
	{end}
end

(*{doc 二乗和
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sums_sum_of_squares: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n: dint;
		i: dint;
		acc: lreal;
		v: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	acc := 0.0;
	for i := 0 to actual_n - 1 do
		v := data[i];
		acc := acc + v * v;
	end_for;
	Stats_sums_sum_of_squares := acc;
	{end}
end

(*{doc 積和
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_sums_sum_of_products: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
		(*{doc サンプルデータを含む配列。}*)
		y: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_nx, actual_ny, actual_n: dint;
		i: dint;
		acc: lreal;
	end
	{st}
	actual_nx := Array_isRegular_lreal(x);
	actual_ny := Array_isRegular_lreal(y);
	if (actual_nx = 0) or (actual_ny = 0) or (n > actual_nx) or (n > actual_ny) then
		eno := false;
		return;
	end_if;
	if n < 0 then
		if actual_nx <> actual_ny then
			eno := false;
			return;
		end_if;
		actual_n := actual_nx;
	else
		actual_n := n;
	end_if;

	acc := 0.0;
	for i := 0 to actual_n - 1 do
		acc := acc + x[i] * y[i];
	end_for;
	Stats_sums_sum_of_products := acc;
	{end}
end

(*{doc 累積和 result[i] = sum(j=0..i) data[j]
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@inout result 結果を格納する配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力値が不正な場合。}*)
function Stats_sums_cumsum
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_in_out
		(*{doc 結果を格納する配列。}*)
		result: array[*] of lreal;
	end
	var_temp
		actual_n: dint;
		i: dint;
		acc: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;
	if Array_size(result) < actual_n then
		eno := false;
		return;
	end_if;

	acc := 0.0;
	for i := 0 to actual_n - 1 do
		acc := acc + data[i];
		result[i] := acc;
	end_for;
	{end}
end

{#endif}

