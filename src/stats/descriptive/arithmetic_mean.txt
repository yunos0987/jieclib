(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/stats/descriptive/arithmetic_mean.txt -I./src -I./vendor/jiecunit/sys -o ./src/stats/descriptive/arithmetic_mean.xml -t omron
 *)
{#ifndef __STATS_DESCRIPTIVE_ARITHMETIC_MEAN_TXT__}
{#define __STATS_DESCRIPTIVE_ARITHMETIC_MEAN_TXT__}

{#include <sys.txt>}
{#include <math/floor.txt>}
{#include <array/array.txt>}
{#include <stats/descriptive/mean.txt>}

(*{doc 算術平均を得る。
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_arithmetic_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc dataの先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	Stats_arithmetic_mean := Stats_mean(data:=data, n:=n, eno=>eno);
	{end}
end

(*{doc 加重算術平均を得る。
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout weights 重みを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_weighted_arithmetic_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
		(*{doc 重みを含む配列。}*)
		weights: array[*] of lreal;
	end
	var_input
		(*{doc dataの先頭n個を使用する。}*)
		n: dint := -1;
	end
	{st}
	Stats_weighted_arithmetic_mean := Stats_weighted_mean(data:=data, w:=weights, n:=n, eno=>eno);
	{end}
end

(*{doc 移動平均を得る。
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input window 入力値。
@inout result 結果を格納する配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力値が不正な場合。}*)
function Stats_moving_average
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc dataの先頭n個を使用する。}*)
		n: dint := -1;
		(*{doc 窓幅。}*)
		window: dint;
	end
	var_in_out
		(*{doc 移動平均の結果配列。}*)
		result: array[*] of lreal;
	end
	var_temp
		ndata, nresult: dint;
		actual_n: dint;
		i: dint;
		acc: lreal;
		w: dint;
	end
	{st}
	ndata := Array_isRegular_lreal(data);
	nresult := Array_isRegular_lreal(result);
	if (ndata = 0) or (nresult = 0) then
		eno := false;
		return;
	end_if;
	if n <= 0 then
		actual_n := ndata;
	else
		actual_n := n;
	end_if;
	if actual_n > ndata then
		eno := false;
		return;
	end_if;
	w := window;
	if (w <= 0) or (w > actual_n) then
		eno := false;
		return;
	end_if;
	if nresult < (actual_n - w + 1) then
		eno := false;
		return;
	end_if;
	acc := 0.0;
	for i := 0 to w - 1 do
		acc := acc + data[i];
	end_for;
	result[0] := acc / dint_to_lreal(w);
	for i := 1 to actual_n - w do
		acc := acc + data[i + w - 1] - data[i - 1];
		result[i] := acc / dint_to_lreal(w);
	end_for;
	{end}
end

{#endif}

