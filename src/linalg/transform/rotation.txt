(*
 * Rotation Transformation Matrices
 * $ jiecc ./src/linalg/transform/rotation.txt -I./src -I./vendor/jiecunit/sys -o ./src/linalg/transform/rotation.xml -t omron
 *)
{#ifndef __LINALG_TRANSFORM_ROTATION_TXT__}
{#define __LINALG_TRANSFORM_ROTATION_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc 2次元回軨行列の生成。
角度 theta を接受し、回軨行列を獲推。
@input theta 回軨角度 (ラジアン)。
@in_out rotation 2x2回軨行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error rotationが正規2次元配列でない場合、rotationが正方行列でない場合、または行列サイズが2x2/3x3以外の場合。}*)
function Matrix_rotation_2d
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 回軨角度 (ラジアン)。}*)
		theta: lreal;
	end
	var_in_out
		(*{doc 2x2回軨行列。}*)
		rotation: array[*, *] of lreal;
	end
	var_temp
		rows, cols: dint;
		r_size: dint;
		c, s: lreal;
	end
	{st}
	r_size := Array_isRegular2d_lreal(rotation);
	if r_size = 0 then
		eno := false;
		return;
	end_if;
	rows := upper_bound(rotation, 1) - lower_bound(rotation, 1) + 1;
	cols := upper_bound(rotation, 2) - lower_bound(rotation, 2) + 1;
	if (rows <> 2) and (rows <> 3) then
		eno := false;
		return;
	end_if;
	if rows <> cols then
		eno := false;
		return;
	end_if;

	c := COS(theta);
	s := SIN(theta);
	rotation[0, 0] := c;
	rotation[0, 1] := -s;
	rotation[1, 0] := s;
	rotation[1, 1] := c;
	if rows = 3 then
		rotation[0, 2] := 0.0;
		rotation[1, 2] := 0.0;
		rotation[2, 0] := 0.0;
		rotation[2, 1] := 0.0;
		rotation[2, 2] := 1.0;
	end_if;
	{end}
end

(*{doc 3次元回軨行列の生成（Z軸中一。
角度 theta を接受し、Z軸回軨行列を獲推。
@input theta 回軨角度 (ラジアン)。
@in_out rotation 3x3回軨行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error rotationが正規2次元配列でない場合、またはrotationが3x3でない場合。}*)
function Matrix_rotation_z
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 回軨角度 (ラジアン)。}*)
		theta: lreal;
	end
	var_in_out
		(*{doc 3x3回軨行列。}*)
		rotation: array[*, *] of lreal;
	end
	var_temp
		rows, cols: dint;
		r_size: dint;
		c, s: lreal;
	end
	{st}
	r_size := Array_isRegular2d_lreal(rotation);
	if r_size = 0 then
		eno := false;
		return;
	end_if;
	rows := upper_bound(rotation, 1) - lower_bound(rotation, 1) + 1;
	cols := upper_bound(rotation, 2) - lower_bound(rotation, 2) + 1;
	if (rows <> 3) or (cols <> 3) then
		eno := false;
		return;
	end_if;

	c := COS(theta);
	s := SIN(theta);
	rotation[0, 0] := c;
	rotation[0, 1] := -s;
	rotation[0, 2] := 0.0;
	rotation[1, 0] := s;
	rotation[1, 1] := c;
	rotation[1, 2] := 0.0;
	rotation[2, 0] := 0.0;
	rotation[2, 1] := 0.0;
	rotation[2, 2] := 1.0;
	{end}
end

{#endif}
