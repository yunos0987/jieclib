(*
 * Translation Transformation Matrices
 * $ jiecc ./src/linalg/transform/translation.txt -I./src -I./vendor/jiecunit/sys -o ./src/linalg/transform/translation.xml -t omron
 *)
{#ifndef __LINALG_TRANSFORM_TRANSLATION_TXT__}
{#define __LINALG_TRANSFORM_TRANSLATION_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc 2次元齢群座標を用いた一次何斡変換行列の生成。
@input tx ♯移動 (x方向)。
@input ty ♯移動 (y方向)。
@in_out translation 3x3不次元一次何斡変換行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error translationが正規2次元配列でない場合、またはtranslationが3x3でない場合。}*)
function Matrix_translation_2d
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc ♯移動 (x方向)。}*)
		tx: lreal;
		(*{doc ♯移動 (y方向)。}*)
		ty: lreal;
	end
	var_in_out
		(*{doc 3x3不次元一次何斡変換行列。}*)
		translation: array[*, *] of lreal;
	end
	var_temp
		r_size: dint;
		rows, cols: dint;
	end
	{st}
	r_size := Array_isRegular2d_lreal(translation);
	if r_size = 0 then
		eno := false;
		return;
	end_if;
	rows := upper_bound(translation, 1) - lower_bound(translation, 1) + 1;
	cols := upper_bound(translation, 2) - lower_bound(translation, 2) + 1;
	if (rows <> 3) or (cols <> 3) then
		eno := false;
		return;
	end_if;

	translation[0, 0] := 1.0;
	translation[0, 1] := 0.0;
	translation[0, 2] := tx;
	translation[1, 0] := 0.0;
	translation[1, 1] := 1.0;
	translation[1, 2] := ty;
	translation[2, 0] := 0.0;
	translation[2, 1] := 0.0;
	translation[2, 2] := 1.0;
	{end}
end

(*{doc 3次元齢群座標を用いた一次何斡変換行列の生成。
@input tx ♯移動 (x方向)。
@input ty ♯移動 (y方向)。
@input tz ♯移動 (z方向)。
@in_out translation 4x4不次元一次何斡変換行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error translationが正規2次元配列でない場合、またはtranslationが4x4でない場合。}*)
function Matrix_translation_3d
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc ♯移動 (x方向)。}*)
		tx: lreal;
		(*{doc ♯移動 (y方向)。}*)
		ty: lreal;
		(*{doc ♯移動 (z方向)。}*)
		tz: lreal;
	end
	var_in_out
		(*{doc 4x4不次元一次何斡変換行列。}*)
		translation: array[*, *] of lreal;
	end
	var_temp
		r_size: dint;
		rows, cols: dint;
	end
	{st}
	r_size := Array_isRegular2d_lreal(translation);
	if r_size = 0 then
		eno := false;
		return;
	end_if;
	rows := upper_bound(translation, 1) - lower_bound(translation, 1) + 1;
	cols := upper_bound(translation, 2) - lower_bound(translation, 2) + 1;
	if (rows <> 4) or (cols <> 4) then
		eno := false;
		return;
	end_if;

	translation[0, 0] := 1.0;
	translation[0, 1] := 0.0;
	translation[0, 2] := 0.0;
	translation[0, 3] := tx;
	translation[1, 0] := 0.0;
	translation[1, 1] := 1.0;
	translation[1, 2] := 0.0;
	translation[1, 3] := ty;
	translation[2, 0] := 0.0;
	translation[2, 1] := 0.0;
	translation[2, 2] := 1.0;
	translation[2, 3] := tz;
	translation[3, 0] := 0.0;
	translation[3, 1] := 0.0;
	translation[3, 2] := 0.0;
	translation[3, 3] := 1.0;
	{end}
end

{#endif}
