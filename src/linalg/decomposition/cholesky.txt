(*
 * Cholesky Decomposition
 * $ jiecc ./src/linalg/decomposition/cholesky.txt -I./src -I./vendor/jiecunit/sys -o ./src/linalg/decomposition/cholesky.xml -t omron
 *)
{#ifndef __LINALG_DECOMPOSITION_CHOLESKY_TXT__}
{#define __LINALG_DECOMPOSITION_CHOLESKY_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc Cholesky分解。
対称正定値行列をCholesky分解し、下三角行列Lを得る。
@in_out a 入力の対称正定値行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out l 結果の下三角行列Lで、A = L * L^Tが成立する。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力値が不正な場合、または行列が正定値でない場合。}*)
function Matrix_cholesky_decompose
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 入力の対称正定値行列。}*)
		a: array[*, *] of lreal;
	end
	var_in_out
		(*{doc 結果の下三角行列L。}*)
		l: array[*, *] of lreal;
	end
	var_temp
		i, j, k: dint;
		n: dint;
		a_size, l_size: dint;
		a_rows, a_cols: dint;
		l_rows, l_cols: dint;
		sum_val: lreal;
	end
	{st}
	a_size := Array_isRegular2d_lreal(a);
	l_size := Array_isRegular2d_lreal(l);
	if (a_size = 0) or (l_size = 0) then
		eno := false;
		return;
	end_if;

	a_rows := upper_bound(a, 1) - lower_bound(a, 1) + 1;
	a_cols := upper_bound(a, 2) - lower_bound(a, 2) + 1;
	l_rows := upper_bound(l, 1) - lower_bound(l, 1) + 1;
	l_cols := upper_bound(l, 2) - lower_bound(l, 2) + 1;
	if a_rows <> a_cols then
		eno := false;
		return;
	end_if;
	if (l_rows <> a_rows) or (l_cols <> a_cols) then
		eno := false;
		return;
	end_if;

	n := a_rows;
	for i := 0 to n - 1 by 1 do
		for j := 0 to n - 1 by 1 do
			l[i, j] := 0.0;
		end_for;
	end_for;

	for i := 0 to n - 1 by 1 do
		for j := 0 to i by 1 do
			sum_val := a[i, j];
			for k := 0 to j - 1 by 1 do
				sum_val := sum_val - l[i, k] * l[j, k];
			end_for;
			if i = j then
				if sum_val <= 0.0 then
					eno := false;
					return;
				end_if;
				l[i, j] := sqrt(sum_val);
			else
				if abs(l[j, j]) < 1e-15 then
					eno := false;
					return;
				end_if;
				l[i, j] := sum_val / l[j, j];
			end_if;
		end_for;
	end_for;
	{end}
end

{#endif}
