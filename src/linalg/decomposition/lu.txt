(*
 * LU Decomposition
 * $ jiecc ./src/linalg/decomposition/lu.txt -I./src -I./vendor/jiecunit/sys -o ./src/linalg/decomposition/lu.xml -t omron
 *)
{#ifndef __LINALG_DECOMPOSITION_LU_TXT__}
{#define __LINALG_DECOMPOSITION_LU_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc LU分解。
行列をLU分解し、下三角行列Lと上三角行列Uを得る。
@in_out a 入力行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out l 結果の下三角行列L。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out u 結果の上三角行列U。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力行列が正規2次元配列でない場合、aが正方行列でない場合、l/uの行列サイズがaと一致しない場合、または分解中に対角要素が0に近くなる場合。}*)
function Matrix_lu_decompose
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 入力行列。}*)
		a: array[*, *] of lreal;
	end
	var_in_out
		(*{doc 結果の下三角行列L。}*)
		l: array[*, *] of lreal;
		(*{doc 結果の上三角行列U。}*)
		u: array[*, *] of lreal;
	end
	var_temp
		i, j, k: dint;
		n: dint;
		a_size, l_size, u_size: dint;
		a_rows, a_cols: dint;
		l_rows, l_cols: dint;
		u_rows, u_cols: dint;
		sum_val: lreal;
	end
	{st}
	a_size := Array_isRegular2d_lreal(a);
	l_size := Array_isRegular2d_lreal(l);
	u_size := Array_isRegular2d_lreal(u);
	if (a_size = 0) or (l_size = 0) or (u_size = 0) then
		eno := false;
		return;
	end_if;

	a_rows := upper_bound(a, 1) - lower_bound(a, 1) + 1;
	a_cols := upper_bound(a, 2) - lower_bound(a, 2) + 1;
	l_rows := upper_bound(l, 1) - lower_bound(l, 1) + 1;
	l_cols := upper_bound(l, 2) - lower_bound(l, 2) + 1;
	u_rows := upper_bound(u, 1) - lower_bound(u, 1) + 1;
	u_cols := upper_bound(u, 2) - lower_bound(u, 2) + 1;
	if a_rows <> a_cols then
		eno := false;
		return;
	end_if;
	if (l_rows <> a_rows) or (l_cols <> a_cols) then
		eno := false;
		return;
	end_if;
	if (u_rows <> a_rows) or (u_cols <> a_cols) then
		eno := false;
		return;
	end_if;

	n := a_rows;
	for i := 0 to n - 1 by 1 do
		for j := 0 to n - 1 by 1 do
			l[i, j] := 0.0;
			u[i, j] := 0.0;
		end_for;
	end_for;

	for i := 0 to n - 1 by 1 do
		for j := i to n - 1 by 1 do
			sum_val := 0.0;
			for k := 0 to i - 1 by 1 do
				sum_val := sum_val + l[i, k] * u[k, j];
			end_for;
			u[i, j] := a[i, j] - sum_val;
		end_for;

		if abs(u[i, i]) < 1e-15 then
			eno := false;
			return;
		end_if;

		l[i, i] := 1.0;
		for j := i + 1 to n - 1 by 1 do
			sum_val := 0.0;
			for k := 0 to i - 1 by 1 do
				sum_val := sum_val + l[j, k] * u[k, i];
			end_for;
			l[j, i] := (a[j, i] - sum_val) / u[i, i];
		end_for;
	end_for;
	{end}
end

{#endif}
