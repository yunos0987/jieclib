(*
 * $ jiecc ./src/vector/utils.txt -I./src -I./vendor/jiecunit/sys -o ./src/vector/utils.xml -t omron
 *)
{#ifndef __VECTOR_UTILS_TXT__}
{#define __VECTOR_UTILS_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc ベクトルが正規配列かどうかを判定する。
@in_out vector 入力ベクトル。
  正規配列（次元の始点が0で要素数1以上）であることを想定。
@return 正規配列ならtrue、そうでなければfalse。
@error 入力ベクトルが正規配列でない場合。}*)
function Vector_utils_is_regular: bool
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		vector: array[*] of lreal;
	end
	var_temp
		size: dint;
	end
	{st}
	size := Array_isRegular_lreal(vector);
	if size = 0 then
		eno := false;
		return;
	end_if;
	Vector_utils_is_regular := true;
	{end}
end

(*{doc ベクトルが実質ゼロベクトルかどうかを判定する。
@in_out vector 入力ベクトル。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input tolerance ゼロ判定の許容誤差。
  デフォルト値: 1e-12
@return ゼロベクトルならtrue、そうでなければfalse。
@error 入力ベクトルが正規配列でない場合、またはtoleranceが負の場合。}*)
function Vector_utils_is_zero: bool
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		vector: array[*] of lreal;
	end
	var_input
		tolerance: lreal := 1e-12;
	end
	var_temp
		i, size: dint;
	end
	{st}
	size := Array_isRegular_lreal(vector);
	if size = 0 then
		eno := false;
		return;
	end_if;
	if tolerance < 0.0 then
		eno := false;
		return;
	end_if;

	Vector_utils_is_zero := true;
	for i := 0 to size - 1 by 1 do
		if abs(vector[i]) > tolerance then
			Vector_utils_is_zero := false;
			return;
		end_if;
	end_for;
	{end}
end

(*{doc ベクトルをL2正規化する。
@in_out vector 入力ベクトル。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out result 正規化結果ベクトル。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input tolerance ゼロノルム判定の許容誤差。
  デフォルト値: 1e-15
@error 入力配列が正規配列でない場合、vectorとresultの要素数が一致しない場合、または入力がゼロベクトルの場合。}*)
function Vector_utils_normalize
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		vector: array[*] of lreal;
	end
	var_in_out
		result: array[*] of lreal;
	end
	var_input
		tolerance: lreal := 1e-15;
	end
	var_temp
		i, v_size, r_size: dint;
		norm_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	r_size := Array_isRegular_lreal(result);
	if (v_size = 0) or (r_size = 0) then
		eno := false;
		return;
	end_if;
	if v_size <> r_size then
		eno := false;
		return;
	end_if;
	if tolerance < 0.0 then
		eno := false;
		return;
	end_if;

	norm_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		norm_val := norm_val + vector[i] * vector[i];
	end_for;
	norm_val := sqrt(norm_val);
	if norm_val <= tolerance then
		eno := false;
		return;
	end_if;

	for i := 0 to v_size - 1 by 1 do
		result[i] := vector[i] / norm_val;
	end_for;
	{end}
end

{#endif}
