(*
 * Vector Norms
 * Contains L1, L2, Lp norms and norm-related functions
 * $ jiecc ./src/vector/norms.txt -I./src -I./vendor/jiecunit/sys -o ./src/vector/norms.xml -t omron
 *)
{#ifndef __LINALG_VECTOR_NORMS_TXT__}
{#define __LINALG_VECTOR_NORMS_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

// L1 Norm
(*{doc ベクトルのL1ノルム（マンハッタン距離）を計算する。
||v||_1 = Σ|v_i|
@in_out vector 対象となるベクトル。正規配列でなければいけない。
@return L1ノルムの値。
@error 入力配列が正規配列でない場合。}*)
function Vector_norm_l1: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 対象となるベクトル。}*)
		vector: array[*] of lreal;
	end
	var_temp
		i, v_size: dint;
		result_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	
	if (v_size = 0) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		result_val := result_val + abs(vector[i]);
	end_for;
	
	Vector_norm_l1 := result_val;
	{end}
end

// L2 Norm
(*{doc ベクトルのL2ノルム（ユークリッド距離）を計算する。
||v||_2 = √(Σv_i²)
@in_out vector 対象となるベクトル。正規配列でなければいけない。
@return L2ノルムの値。
@error 入力配列が正規配列でない場合。}*)
function Vector_norm_l2: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 対象となるベクトル。}*)
		vector: array[*] of lreal;
	end
	var_temp
		i, v_size: dint;
		result_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	
	if (v_size = 0) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		result_val := result_val + vector[i] * vector[i];
	end_for;
	
	Vector_norm_l2 := sqrt(result_val);
	{end}
end

// L∞ Norm
(*{doc ベクトルのL∞ノルム（最大ノルム）を計算する。
||v||_∞ = max|v_i|
@in_out vector 対象となるベクトル。正規配列でなければいけない。
@return L∞ノルムの値。
@error 入力配列が正規配列でない場合。}*)
function Vector_norm_linf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 対象となるベクトル。}*)
		vector: array[*] of lreal;
	end
	var_temp
		i, v_size: dint;
		result_val, abs_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	
	if (v_size = 0) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		abs_val := abs(vector[i]);
		if (abs_val > result_val) then
			result_val := abs_val;
		end_if;
	end_for;
	
	Vector_norm_linf := result_val;
	{end}
end

// Lp Norm
(*{doc ベクトルのLpノルムを計算する。
||v||_p = (Σ|v_i|^p)^(1/p)
@in_out vector 対象となるベクトル。正規配列でなければいけない。
@input p ノルムの次数（p > 0）。
@return Lpノルムの値。
@error 入力配列が正規配列でない場合、またはp <= 0の場合。}*)
function Vector_norm_lp: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 対象となるベクトル。}*)
		vector: array[*] of lreal;
	end
	var_input
		(*{doc ノルムの次数（p > 0）。}*)
		p: lreal;
	end
	var_temp
		i, v_size: dint;
		result_val: lreal;
	end
	{st}
	if (p <= 0.0) then
		eno := false;
		return;
	end_if;
	
	v_size := Array_isRegular_lreal(vector);
	
	if (v_size = 0) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		result_val := result_val + (abs(vector[i]) ** p);
	end_for;
	
	Vector_norm_lp := result_val ** (1.0 / p);
	{end}
end

// Vector Normalization
(*{doc ベクトルをL2ノルムで正規化する。
result = vector / ||vector||_2
@in_out vector 正規化するベクトル。正規配列でなければいけない。
@in_out result 正規化されたベクトルを格納する配列。正規配列でなければいけない。
@error 入力配列が正規配列でない場合、またはベクトルがゼロベクトルの場合。}*)
function Vector_normalize_l2
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 正規化するベクトル。}*)
		vector: array[*] of lreal;
	end
	var_in_out
		(*{doc 正規化されたベクトルを格納する配列。}*)
		result: array[*] of lreal;
	end
	var_temp
		i, v_size, r_size: dint;
		norm_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	r_size := Array_isRegular_lreal(result);
	
	if (v_size = 0) or (r_size = 0) then
		eno := false;
		return;
	end_if;
	
	if (v_size <> r_size) then
		eno := false;
		return;
	end_if;
	
	norm_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		norm_val := norm_val + vector[i] * vector[i];
	end_for;
	norm_val := sqrt(norm_val);
	
	if (norm_val < 1e-15) then
		eno := false;
		return;
	end_if;
	
	for i := 0 to v_size - 1 by 1 do
		result[i] := vector[i] / norm_val;
	end_for;
	{end}
end

// Distance Functions
(*{doc 2つのベクトル間のL1距離を計算する。
||a - b||_1
@in_out a ベクトルA。正規配列でなければいけない。
@in_out b ベクトルB。正規配列でなければいけない。
@return L1距離の値。
@error 入力配列が正規配列でない場合、またはサイズが異なる場合。}*)
function Vector_distance_l1: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc ベクトルA。}*)
		a: array[*] of lreal;
		(*{doc ベクトルB。}*)
		b: array[*] of lreal;
	end
	var_temp
		i, a_size, b_size: dint;
		result_val: lreal;
	end
	{st}
	a_size := Array_isRegular_lreal(a);
	b_size := Array_isRegular_lreal(b);
	
	if (a_size = 0) or (b_size = 0) then
		eno := false;
		return;
	end_if;
	
	if (a_size <> b_size) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to a_size - 1 by 1 do
		result_val := result_val + abs(a[i] - b[i]);
	end_for;
	
	Vector_distance_l1 := result_val;
	{end}
end

(*{doc 2つのベクトル間のL2距離を計算する。
||a - b||_2
@in_out a ベクトルA。正規配列でなければいけない。
@in_out b ベクトルB。正規配列でなければいけない。
@return L2距離の値。
@error 入力配列が正規配列でない場合、またはサイズが異なる場合。}*)
function Vector_distance_l2: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc ベクトルA。}*)
		a: array[*] of lreal;
		(*{doc ベクトルB。}*)
		b: array[*] of lreal;
	end
	var_temp
		i, a_size, b_size: dint;
		result_val, diff: lreal;
	end
	{st}
	a_size := Array_isRegular_lreal(a);
	b_size := Array_isRegular_lreal(b);
	
	if (a_size = 0) or (b_size = 0) then
		eno := false;
		return;
	end_if;
	
	if (a_size <> b_size) then
		eno := false;
		return;
	end_if;
	
	result_val := 0.0;
	for i := 0 to a_size - 1 by 1 do
		diff := a[i] - b[i];
		result_val := result_val + diff * diff;
	end_for;
	
	Vector_distance_l2 := sqrt(result_val);
	{end}
end

(*{doc 2つのベクトル間のL∞距離を計算する。
||a - b||_∞
@in_out a ベクトルA。正規配列でなければいけない。
@in_out b ベクトルB。正規配列でなければいけない。
@return L∞距離の値。
@error 入力配列が正規配列でない場合、またはサイズが異なる場合。}*)
function Vector_distance_linf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc ベクトルA。}*)
		a: array[*] of lreal;
		(*{doc ベクトルB。}*)
		b: array[*] of lreal;
	end
	var_temp
		i, a_size, b_size: dint;
		max_diff, diff: lreal;
	end
	{st}
	a_size := Array_isRegular_lreal(a);
	b_size := Array_isRegular_lreal(b);
	
	if (a_size = 0) or (b_size = 0) then
		eno := false;
		return;
	end_if;
	
	if (a_size <> b_size) then
		eno := false;
		return;
	end_if;
	
	max_diff := 0.0;
	for i := 0 to a_size - 1 by 1 do
		diff := abs(a[i] - b[i]);
		if (diff > max_diff) then
			max_diff := diff;
		end_if;
	end_for;
	
	Vector_distance_linf := max_diff;
	{end}
end

// Unit Vector Test
(*{doc ベクトルが単位ベクトルかどうかをチェックする。
||vector||_2 ≈ 1
@in_out vector 確認するベクトル。正規配列でなければいけない。
@input tolerance 許容誤差。
@return 単位ベクトルかどうか。
@error 入力配列が正規配列でない場合。}*)
function Vector_is_unit: bool
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 確認するベクトル。}*)
		vector: array[*] of lreal;
	end
	var_input
		(*{doc 許容誤差。}*)
		tolerance: lreal;
	end
	var_temp
		i, v_size: dint;
		norm_val: lreal;
	end
	{st}
	v_size := Array_isRegular_lreal(vector);
	
	if (v_size = 0) then
		eno := false;
		return;
	end_if;
	
	norm_val := 0.0;
	for i := 0 to v_size - 1 by 1 do
		norm_val := norm_val + vector[i] * vector[i];
	end_for;
	norm_val := sqrt(norm_val);
	
	Vector_is_unit := (abs(norm_val - 1.0) < tolerance);
	{end}
end

{#endif}