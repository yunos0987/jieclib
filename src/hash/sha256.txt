(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./src/hash/sha256.txt -I./src -I./vendor/jiecunit/sys -o ./src/hash/sha256.xml -t omron
 *)
{#ifndef __HASH_SHA256_TXT__}
{#define __HASH_SHA256_TXT__}

{#include <sys.txt>}
{#include <sys_conv.txt>}
{#include <string_lib/string_lib.txt>}

{#define STRING string[STRING_MAX_SIZE]}

(*{doc SHA-256で使用する32bit整数化を行う。
@input n 入力整数（64bit）。
@return nの下位32bitをUDINTとして返す。}*)
function private_SHA256_number: udint
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力整数（64bit）。}*)
		n: lint;
	end
	{st}
	private_SHA256_number := dword_to_udint(lint_to_dword(n));
	{end}
end

(*{doc 32bit値を右ローテートする。
@input x 入力値。
@input c ローテートビット数。
@return 右ローテート後の値。}*)
function private_SHA256_rightrotate: dword
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		x: dword;
		(*{doc ローテートビット数。}*)
		c: dint;
	end
	{st}
	private_SHA256_rightrotate := shr(x, c) or shl(x, 32 - c);
	{end}
end

(*{doc 1バイトを16進2桁文字列へ変換する。
@input b 入力バイト。
@return 小文字16進2桁文字列。}*)
function private_SHA256_hexbyte: string[2 + 1]
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力バイト。}*)
		b: byte;
	end
	var_temp
		HEX: array[0..15] of string[1 + 1] constant := [
			'0','1','2','3','4','5','6','7','8','9','a','b','c','d','e','f'
		];
		hi, lo: dint;
	end
	{st}
	hi := byte_to_dint(shr(b, 4));
	lo := byte_to_dint(b and byte#16#0F);
	private_SHA256_hexbyte := concat(HEX[hi], HEX[lo]);
	{end}
end

(*{doc 32bit値を16進8桁文字列へ変換する。
@input w 入力32bit値。
@return 16進8桁文字列。}*)
function private_SHA256_hexword_be: string[8 + 1]
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力32bit値。}*)
		w: dword;
	end
	var_temp
		b0, b1, b2, b3: byte;
	end
	{st}
	b0 := dword_to_byte(shr(w, 24) and dword#16#000000FF);
	b1 := dword_to_byte(shr(w, 16) and dword#16#000000FF);
	b2 := dword_to_byte(shr(w, 8) and dword#16#000000FF);
	b3 := dword_to_byte(w and dword#16#000000FF);
	private_SHA256_hexword_be := jiec_concat(private_SHA256_hexbyte(b0), private_SHA256_hexbyte(b1), private_SHA256_hexbyte(b2), private_SHA256_hexbyte(b3));
	{end}
end

(*{doc 文字列のSHA-256ダイジェスト（64文字16進小文字）を得る。
@input txt 入力文字列（ASCII想定）。
@in_out work 入力文字列を展開する作業用バイト配列。
	必要要素数はlen(txt) + 72以上。
@return SHA-256ハッシュ文字列。
@error ASCIIコード取得に失敗した場合、またはwork容量不足の場合。}*)
function SHA256_string: string[64 + 1]
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力文字列（ASCII想定）。}*)
		txt: STRING;
	end
	var_in_out
		(*{doc 作業用バイト配列。必要要素数はlen(txt) + 72以上。}*)
		work: array[*] of byte;
	end
	var_temp
		w0, w1: dint;
		input_len: dint;
		i: dint;
		code: dint;
	end
	{st}
	w0 := lower_bound(work, 1);
	w1 := upper_bound(work, 1);
	input_len := uint_to_dint(len(txt));
	if (input_len + 72) > (w1 - w0 + 1) then
		eno := false;
		return;
	end_if;

	for i := 0 to input_len - 1 by 1 do
		code := String_asciiCharCodeAt(txt, i);
		if (code < 0) or (code > 127) then
			eno := false;
			return;
		end_if;
		work[w0 + i] := dint_to_byte(code);
	end_for;

	SHA256_string := SHA256_bytes(dat:=work, offset:=0, length:=input_len, work:=work, eno=>eno);
	if not eno then
		return;
	end_if;
	{end}
end

(*{doc バイト配列のSHA-256ダイジェスト（64文字16進小文字）を得る。
@in_out dat 入力バイト配列。
@input offset datの開始オフセット。
	デフォルト値: 0
@input length ハッシュ対象の要素数。
	-1を指定するとき、offsetから末尾までを対象とする。
	デフォルト値: -1
@in_out work SHA-256計算に使用する作業用バイト配列。
	必要要素数は実入力長 + 72以上。
@return SHA-256ハッシュ文字列。
@error offset/lengthが配列範囲外を指す場合、またはwork容量不足の場合。}*)
function SHA256_bytes: string[64 + 1]
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 入力バイト配列。}*)
		dat: array[*] of byte;
	end
	var_input
		(*{doc datの開始オフセット。}*)
		offset: dint := 0;
		(*{doc ハッシュ対象の要素数。-1で末尾まで。}*)
		length: dint := -1;
	end
	var_in_out
		(*{doc 作業用バイト配列。必要要素数は実入力長 + 72以上。}*)
		work: array[*] of byte;
	end
	var_temp
		K: array[0..63] of dword constant := [
			dword#16#428A2F98, dword#16#71374491, dword#16#B5C0FBCF, dword#16#E9B5DBA5,
			dword#16#3956C25B, dword#16#59F111F1, dword#16#923F82A4, dword#16#AB1C5ED5,
			dword#16#D807AA98, dword#16#12835B01, dword#16#243185BE, dword#16#550C7DC3,
			dword#16#72BE5D74, dword#16#80DEB1FE, dword#16#9BDC06A7, dword#16#C19BF174,
			dword#16#E49B69C1, dword#16#EFBE4786, dword#16#0FC19DC6, dword#16#240CA1CC,
			dword#16#2DE92C6F, dword#16#4A7484AA, dword#16#5CB0A9DC, dword#16#76F988DA,
			dword#16#983E5152, dword#16#A831C66D, dword#16#B00327C8, dword#16#BF597FC7,
			dword#16#C6E00BF3, dword#16#D5A79147, dword#16#06CA6351, dword#16#14292967,
			dword#16#27B70A85, dword#16#2E1B2138, dword#16#4D2C6DFC, dword#16#53380D13,
			dword#16#650A7354, dword#16#766A0ABB, dword#16#81C2C92E, dword#16#92722C85,
			dword#16#A2BFE8A1, dword#16#A81A664B, dword#16#C24B8B70, dword#16#C76C51A3,
			dword#16#D192E819, dword#16#D6990624, dword#16#F40E3585, dword#16#106AA070,
			dword#16#19A4C116, dword#16#1E376C08, dword#16#2748774C, dword#16#34B0BCB5,
			dword#16#391C0CB3, dword#16#4ED8AA4A, dword#16#5B9CCA4F, dword#16#682E6FF3,
			dword#16#748F82EE, dword#16#78A5636F, dword#16#84C87814, dword#16#8CC70208,
			dword#16#90BEFFFA, dword#16#A4506CEB, dword#16#BEF9A3F7, dword#16#C67178F2
		];
		W: array[0..63] of dword;
		i0, i1: dint;
		w0, w1: dint;
		startindex, endindex: dint;
		input_len, total_len, num_blocks: dint;
		pad_zero_count: dint;
		i, t, blk, j: dint;
		bit_len: ulint;
		tmp_bit_len: ulint;
		h0, h1, h2, h3, h4, h5, h6, h7: dword;
		a, b, c, d, e, f, g, h: dword;
		S_0, S_1, ch, maj, temp1, temp2, s0, s1: dword;
		tmp64: lint;
	end
	{st}
	i0 := lower_bound(dat, 1);
	i1 := upper_bound(dat, 1);
	w0 := lower_bound(work, 1);
	w1 := upper_bound(work, 1);

	if length < -1 then
		eno := false;
		return;
	end_if;

	if length = 0 then
		if (offset < 0) or (offset > (i1 - i0 + 1)) then
			eno := false;
			return;
		end_if;
		input_len := 0;
	else
		startindex := i0 + offset;
		if length = -1 then
			endindex := i1;
		else
			endindex := startindex + length - 1;
		end_if;
		if (startindex < i0) or (endindex < startindex) or (endindex > i1) then
			eno := false;
			return;
		end_if;
		input_len := endindex - startindex + 1;
	end_if;

	if (input_len + 72) > (w1 - w0 + 1) then
		eno := false;
		return;
	end_if;

	for i := 0 to input_len - 1 by 1 do
		work[w0 + i] := dat[startindex + i];
	end_for;

	work[w0 + input_len] := byte#16#80;
	pad_zero_count := (56 - ((input_len + 1) mod 64) + 64) mod 64;
	for i := 1 to pad_zero_count by 1 do
		work[w0 + input_len + i] := byte#16#00;
	end_for;

	total_len := input_len + 1 + pad_zero_count + 8;
	bit_len := dint_to_ulint(input_len) * ulint#8;
	tmp_bit_len := bit_len;
	for i := 0 to 7 by 1 do
		work[w0 + total_len - 1 - i] := ulint_to_byte(tmp_bit_len);
		tmp_bit_len := tmp_bit_len / ulint#256;
	end_for;
	num_blocks := total_len / 64;

	h0 := dword#16#6A09E667;
	h1 := dword#16#BB67AE85;
	h2 := dword#16#3C6EF372;
	h3 := dword#16#A54FF53A;
	h4 := dword#16#510E527F;
	h5 := dword#16#9B05688C;
	h6 := dword#16#1F83D9AB;
	h7 := dword#16#5BE0CD19;

	for blk := 0 to num_blocks - 1 by 1 do
		for t := 0 to 15 by 1 do
			j := w0 + blk * 64 + t * 4;
			W[t] :=
				shl(udint_to_dword(byte_to_udint(work[j])), 24) or
				shl(udint_to_dword(byte_to_udint(work[j + 1])), 16) or
				shl(udint_to_dword(byte_to_udint(work[j + 2])), 8) or
				udint_to_dword(byte_to_udint(work[j + 3]));
		end_for;
		for t := 16 to 63 by 1 do
			s0 := private_SHA256_rightrotate(W[t - 15], 7) xor private_SHA256_rightrotate(W[t - 15], 18) xor shr(W[t - 15], 3);
			s1 := private_SHA256_rightrotate(W[t - 2], 17) xor private_SHA256_rightrotate(W[t - 2], 19) xor shr(W[t - 2], 10);
			tmp64 := udint_to_lint(dword_to_udint(W[t - 16])) + udint_to_lint(dword_to_udint(s0)) + udint_to_lint(dword_to_udint(W[t - 7])) + udint_to_lint(dword_to_udint(s1));
			W[t] := udint_to_dword(private_SHA256_number(tmp64));
		end_for;

		a := h0;
		b := h1;
		c := h2;
		d := h3;
		e := h4;
		f := h5;
		g := h6;
		h := h7;

		for t := 0 to 63 by 1 do
			S_1 := private_SHA256_rightrotate(e, 6) xor private_SHA256_rightrotate(e, 11) xor private_SHA256_rightrotate(e, 25);
			ch := (e and f) xor ((not e) and g);
			tmp64 := udint_to_lint(dword_to_udint(h)) + udint_to_lint(dword_to_udint(S_1)) + udint_to_lint(dword_to_udint(ch)) + udint_to_lint(dword_to_udint(K[t])) + udint_to_lint(dword_to_udint(W[t]));
			temp1 := udint_to_dword(private_SHA256_number(tmp64));
			S_0 := private_SHA256_rightrotate(a, 2) xor private_SHA256_rightrotate(a, 13) xor private_SHA256_rightrotate(a, 22);
			maj := (a and b) xor (a and c) xor (b and c);
			tmp64 := udint_to_lint(dword_to_udint(S_0)) + udint_to_lint(dword_to_udint(maj));
			temp2 := udint_to_dword(private_SHA256_number(tmp64));

			h := g;
			g := f;
			f := e;
			tmp64 := udint_to_lint(dword_to_udint(d)) + udint_to_lint(dword_to_udint(temp1));
			e := udint_to_dword(private_SHA256_number(tmp64));
			d := c;
			c := b;
			b := a;
			tmp64 := udint_to_lint(dword_to_udint(temp1)) + udint_to_lint(dword_to_udint(temp2));
			a := udint_to_dword(private_SHA256_number(tmp64));
		end_for;

		h0 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h0)) + udint_to_lint(dword_to_udint(a))));
		h1 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h1)) + udint_to_lint(dword_to_udint(b))));
		h2 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h2)) + udint_to_lint(dword_to_udint(c))));
		h3 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h3)) + udint_to_lint(dword_to_udint(d))));
		h4 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h4)) + udint_to_lint(dword_to_udint(e))));
		h5 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h5)) + udint_to_lint(dword_to_udint(f))));
		h6 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h6)) + udint_to_lint(dword_to_udint(g))));
		h7 := udint_to_dword(private_SHA256_number(udint_to_lint(dword_to_udint(h7)) + udint_to_lint(dword_to_udint(h))));
	end_for;

	SHA256_bytes := jiec_concat(
		private_SHA256_hexword_be(h0),
		private_SHA256_hexword_be(h1),
		private_SHA256_hexword_be(h2),
		private_SHA256_hexword_be(h3),
		private_SHA256_hexword_be(h4),
		private_SHA256_hexword_be(h5),
		private_SHA256_hexword_be(h6),
		private_SHA256_hexword_be(h7)
	);
	{end}
end

{#endif}
