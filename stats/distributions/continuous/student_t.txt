(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./stats/distributions/continuous/student_t.txt -I. -I./vendor/jiecunit/sys -o ./stats/distributions/continuous/student_t.xml -t omron
 *)
{#ifndef __STATS_DISTRIBUTIONS_CONTINUOUS_STUDENT_T_TXT__}
{#define __STATS_DISTRIBUTIONS_CONTINUOUS_STUDENT_T_TXT__}

{#include <sys.txt>}
{#include <stats/distributions/core/special_functions.txt>}
{#include <stats/distributions/continuous/normal.txt>}

(*{doc Student t 分布の確率密度関数。f = 自由度。
f(t) = Gamma((df+1)/2) / (sqrt(pi*df)*Gamma(df/2)) * (1 + t^2/df)^(-(df+1)/2)
@input t 入力値。
@input df 自由度。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_student_t_pdf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		t: lreal;
		(*{doc 自由度。}*)
		df: lreal;
	end
	var_temp logC, logK: lreal; end
	{st}
		if df <= 0.0 then
			eno := false;
			Stats_student_t_pdf := 0.0;
			return;
		end_if;

		logC := Stats_lgamma((df + 1.0) / 2.0) - (0.5 * (ln(df) + ln(3.14159265358979323846)) + Stats_lgamma(df / 2.0));
		logK := -((df + 1.0) / 2.0) * ln(1.0 + (t * t) / df);
		Stats_student_t_pdf := exp(logC + logK);
	{end}
end

(*{doc Student t 分布の累積分布関数。正規化不完全ベータ関数による近似。
df > 0 かつ t は任意
@input t 入力値。
@input df 自由度。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_student_t_cdf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 入力値。}*)
		t: lreal;
		(*{doc 自由度。}*)
		df: lreal;
	end
	var_temp x, a, b, I_x_a_b: lreal; end
	{st}
		if df <= 0.0 then
			eno := false;
			Stats_student_t_cdf := 0.0;
			return;
		end_if;

		if t = 0.0 then
			Stats_student_t_cdf := 0.5;
			return;
		end_if;

		x := df / (df + t * t);
		a := df / 2.0;
		b := 0.5;
		I_x_a_b := Stats_beta_incomplete(x:=x, a:=a, b:=b);

		// 対称性: t>0 なら上側を使用
		if t > 0.0 then
			Stats_student_t_cdf := 1.0 - 0.5 * I_x_a_b;
		else
			Stats_student_t_cdf := 0.5 * I_x_a_b;
		end_if;
	{end}
end

(*{doc Student t 分布の分位関数。Newton-Raphson 法
@input p 確率(0..1)。
@input df 自由度。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_student_t_ppf: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 確率(0..1)。}*)
		p: lreal;
		(*{doc 自由度。}*)
		df: lreal;
	end
	var_temp
		t, delta, cdf_val, pdf_val: lreal;
		z, sign, tail_p, t2, correction: lreal;
		i: dint;
	end
	{st}
		if df <= 0.0 or p < 0.0 or p > 1.0 then
			eno := false;
			Stats_student_t_ppf := 0.0;
			return;
		end_if;

		if p = 0.0 then
			Stats_student_t_ppf := -1e10;
			return;
		end_if;
		if p = 1.0 then
			Stats_student_t_ppf := 1e10;
			return;
		end_if;
		if p = 0.5 then
			Stats_student_t_ppf := 0.0;
			return;
		end_if;

		// 片側確率に変換して初期推定を安定化
		if p < 0.5 then
			tail_p := p;
			sign := -1.0;
		else
			tail_p := 1.0 - p;
			sign := 1.0;
		end_if;

		// 正規分布近似で初期値を求める
		z := Stats_normal_ppf(p:=1.0 - tail_p, mu:=0.0, sigma:=1.0);
		t := z;
		if df > 2.0 then
			t2 := t * t;
			correction := (t * (t2 + 1.0)) / (4.0 * df) + (t * (5.0 * t2 * t2 + 16.0 * t2 + 3.0)) / (96.0 * df * df);
			t := t + correction;
		end_if;
		t := sign * t;

		// Newton-Raphson 反復
		for i := 0 to 49 do
			cdf_val := Stats_student_t_cdf(t:=t, df:=df);
			pdf_val := Stats_student_t_pdf(t:=t, df:=df);
			if pdf_val <= 0.0 then
				exit;
			end_if;
			delta := (cdf_val - p) / pdf_val;
			if delta > 5.0 then
				delta := 5.0;
			elsif delta < -5.0 then
				delta := -5.0;
			end_if;
			t := t - delta;
			if abs(delta) < 1e-10 then
				exit;
			end_if;
		end_for;

		Stats_student_t_ppf := t;
	{end}
end

(*{doc Student t 分布の平均（期待値）。
@input df 自由度。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_student_t_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 自由度。}*)
		df: lreal;
	end
	{st}
		if df <= 1.0 then
			eno := false;
			Stats_student_t_mean := 0.0;
			return;
		end_if;
		Stats_student_t_mean := 0.0;
	{end}
end

(*{doc Student t 分布の分散
@input df 自由度。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_student_t_variance: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 自由度。}*)
		df: lreal;
	end
	{st}
		if df <= 2.0 then
			eno := false;
			Stats_student_t_variance := 0.0;
			return;
		end_if;

		Stats_student_t_variance := df / (df - 2.0);
	{end}
end

{#endif}

