(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./stats/descriptive/mad.txt -I. -I./vendor/jiecunit/sys -o ./stats/descriptive/mad.xml -t omron
 *)
{#ifndef __STATS_DESCRIPTIVE_MAD_TXT__}
{#define __STATS_DESCRIPTIVE_MAD_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <array/copy.txt>}
{#include <stats/descriptive/mean.txt>}
{#include <stats/descriptive/median.txt>}
{#include <stats/sequences/sort_select.txt>}

(*{doc 平均絶対偏差: (1/n) * sum(|x - mean(x)|)
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_mean_absolute_deviation: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_temp
		actual_n, i: dint;
		mu, acc: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	mu := Stats_mean(data:=data, n:=actual_n);

	acc := 0.0;
	for i := 0 to actual_n - 1 do
		acc := acc + abs(data[i] - mu);
	end_for;

	Stats_mean_absolute_deviation := acc / dint_to_lreal(actual_n);
	{end}
end

(*{doc 中央絶対偏差: median(|x - median(x)|) * scale
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input scale 入力値。
  デフォルト値: 1.0
@inout work1 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout work2 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout work3 作業配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_median_absolute_deviation: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_input
		(*{doc スケール係数。}*)
		scale: lreal := 1.0;
	end
	var_in_out
		(*{doc 作業配列。}*)
		work1: array[*] of lreal;
		(*{doc 作業配列。}*)
		work2: array[*] of lreal;
		(*{doc 作業配列。}*)
		work3: array[*] of lreal;
	end
	var_temp
		actual_n, i: dint;
		nwork1, nwork2, nwork3: dint;
		m: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	nwork1 := Array_isRegular_lreal(work1);
	if nwork1 < actual_n then
		eno := false;
		return;
	end_if;
	nwork2 := Array_isRegular_lreal(work2);
	if nwork2 < actual_n then
		eno := false;
		return;
	end_if;
	nwork3 := Array_isRegular_lreal(work3);
	if nwork3 < actual_n then
		eno := false;
		return;
	end_if;

	m := Stats_median(data:=data, n:=actual_n, work1:=work1, work2:=work2);

	for i := 0 to actual_n - 1 do
		work2[i] := abs(data[i] - m);
	end_for;

	Stats_median_absolute_deviation := scale * Stats_median(data:=work2, n:=actual_n, work1:=work1, work2:=work3);
	{end}
end

{#endif}

