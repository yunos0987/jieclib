(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./stats/descriptive/standard_error.txt -I. -I./vendor/jiecunit/sys -o ./stats/descriptive/standard_error.xml -t omron
 *)
{#ifndef __STATS_DESCRIPTIVE_STANDARD_ERROR_TXT__}
{#define __STATS_DESCRIPTIVE_STANDARD_ERROR_TXT__}

{#include <sys.txt>}
{#include <stats/descriptive/variance.txt>}

(*{doc 平均値の標準誤差
SE = std / sqrt(n)
@inout data サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@input ddof 自由度補正。
  デフォルト値: 1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_standard_error_mean: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		data: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
		(*{doc 自由度補正。}*)
		ddof: dint := 1;
	end
	var_temp
		actual_n: dint;
		std_val, var_val: lreal;
	end
	{st}
	actual_n := Array_isRegular_lreal(data);
	if (actual_n = 0) or (n > actual_n) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	end_if;

	if actual_n < 2 then
		eno := false;
		return;
	end_if;

	var_val := Stats_variance_ddof(data:=data, n:=actual_n, ddof:=ddof, eno=>eno);
	if not eno then
		return;
	end_if;
	Stats_standard_error_mean := sqrt(var_val / dint_to_lreal(actual_n));
	{end}
end

(*{doc 比率の標準誤差
SE_p = sqrt(p * (1 - p) / n)
@input p 入力値。
@input n 先頭n個を使用する。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_standard_error_proportion: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_input
		(*{doc 比率。}*)
		p: lreal;
		(*{doc 標本数。}*)
		n: dint;
	end
	{st}
	if (n <= 0) or (p < 0.0) or (p > 1.0) then
		eno := false;
		return;
	end_if;

	Stats_standard_error_proportion := sqrt(p * (1.0 - p) / dint_to_lreal(n));
	{end}
end

(*{doc 2 平均の差の標準誤差（等分散の仮定）
SE = sqrt(s_p^2 * (1/n_x + 1/n_y))
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n_x 入力値。
  デフォルト値: -1
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n_y 入力値。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_standard_error_difference_of_means: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n_x個を使用する。}*)
		n_x: dint := -1;
	end
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		y: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n_y個を使用する。}*)
		n_y: dint := -1;
	end
	var_temp
		actual_nx, actual_ny: dint;
		var_x, var_y, s_p_sq: lreal;
	end
	{st}
	actual_nx := Array_isRegular_lreal(x);
	if (actual_nx = 0) or (n_x > actual_nx) then
		eno := false;
		return;
	end_if;
	if n_x > 0 then
		actual_nx := n_x;
	end_if;

	actual_ny := Array_isRegular_lreal(y);
	if (actual_ny = 0) or (n_y > actual_ny) then
		eno := false;
		return;
	end_if;
	if n_y > 0 then
		actual_ny := n_y;
	end_if;

	if (actual_nx < 2) or (actual_ny < 2) then
		eno := false;
		return;
	end_if;

	var_x := Stats_sample_variance(data:=x, n:=actual_nx, eno=>eno);
	if not eno then
		return;
	end_if;
	var_y := Stats_sample_variance(data:=y, n:=actual_ny, eno=>eno);
	if not eno then
		return;
	end_if;

	s_p_sq := (dint_to_lreal(actual_nx - 1) * var_x + dint_to_lreal(actual_ny - 1) * var_y) / dint_to_lreal(actual_nx + actual_ny - 2);

	Stats_standard_error_difference_of_means := sqrt(s_p_sq * (1.0 / dint_to_lreal(actual_nx) + 1.0 / dint_to_lreal(actual_ny)));
	{end}
end

(*{doc 2 サンプルの差の標準誤差（等分散・異分散対応） - equal_var=true: pooled variance, equal_var=false: Welch method
@inout sample1 入力値。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout sample2 入力値。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input sample_size 入力値。
  デフォルト値: -1
@input equal_var 入力値。
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_standard_error_difference: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		sample1: array[*] of lreal;
		(*{doc サンプルデータを含む配列。}*)
		sample2: array[*] of lreal;
	end
	var_input
		(*{doc 標本数。}*)
		sample_size: dint := -1;
		(*{doc 等分散を仮定するか。}*)
		equal_var: bool;
	end
	var_temp
		actual_n1, actual_n2: dint;
		var1, var2, se_sq: lreal;
	end
	{st}
	actual_n1 := Array_isRegular_lreal(sample1);
	if (actual_n1 = 0) or (sample_size > actual_n1) then
		eno := false;
		return;
	end_if;
	actual_n2 := Array_isRegular_lreal(sample2);
	if (actual_n2 = 0) or (sample_size > actual_n2) then
		eno := false;
		return;
	end_if;
	if sample_size > 0 then
		actual_n1 := sample_size;
		actual_n2 := sample_size;
	end_if;

	var1 := Stats_sample_variance(data:=sample1, n:=actual_n1, eno=>eno);
	if not eno then
		return;
	end_if;
	var2 := Stats_sample_variance(data:=sample2, n:=actual_n2, eno=>eno);
	if not eno then
		return;
	end_if;

	if equal_var then
		// Pooled variance
		Stats_standard_error_difference := Stats_standard_error_difference_of_means(x:=sample1, n_x:=actual_n1, y:=sample2, n_y:=actual_n2);
	else
		// Welch's method: SE = sqrt(s1^2/n1 + s2^2/n2)
		se_sq := var1 / dint_to_lreal(actual_n1) + var2 / dint_to_lreal(actual_n2);
		Stats_standard_error_difference := sqrt(se_sq);
	end_if;
	{end}
end

(*{doc 線形回帰の標準誤差（傾き・切片）
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n 先頭n個を使用する。
  デフォルト値: -1
@output se_slope 出力値。
@output se_intercept 出力値。
@error 入力値が不正な場合。}*)
function Stats_standard_error_regression
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc サンプルデータを含む配列。}*)
		x: array[*] of lreal;
		(*{doc サンプルデータを含む配列。}*)
		y: array[*] of lreal;
	end
	var_input
		(*{doc 先頭n個を使用する。}*)
		n: dint := -1;
	end
	var_output
		(*{doc 傾きの標準誤差。}*)
		se_slope: lreal;
		(*{doc 切片の標準誤差。}*)
		se_intercept: lreal;
	end
	var_temp
		n_x, n_y: dint;
		actual_n: dint;
		m_x, m_y, ss_x, ss_xy, slope, intercept: lreal;
		i: dint;
		diff_x, residual, sse, mse: lreal;
	end
	{st}
	n_x := Array_isRegular_lreal(x);
	n_y := Array_isRegular_lreal(y);
	if (n_x = 0) or (n_y = 0) or (n > n_x) or (n > n_y) then
		eno := false;
		return;
	end_if;
	if n >= 0 then
		actual_n := n;
	else
		if n_x <> n_y then
			eno := false;
			return;
		end_if;
		actual_n := n_x;
	end_if;

	if actual_n < 3 then
		eno := false;
		return;
	end_if;

	m_x := 0.0;
	m_y := 0.0;
	for i := 0 to actual_n - 1 do
		m_x := m_x + x[i];
		m_y := m_y + y[i];
	end_for;
	m_x := m_x / dint_to_lreal(actual_n);
	m_y := m_y / dint_to_lreal(actual_n);

	ss_x := 0.0;
	ss_xy := 0.0;
	for i := 0 to actual_n - 1 do
		diff_x := x[i] - m_x;
		ss_x := ss_x + diff_x * diff_x;
		ss_xy := ss_xy + diff_x * (y[i] - m_y);
	end_for;

	if ss_x = 0.0 then
		eno := false;
		return;
	end_if;

	slope := ss_xy / ss_x;
	intercept := m_y - slope * m_x;

	sse := 0.0;
	for i := 0 to actual_n - 1 do
		residual := y[i] - (slope * x[i] + intercept);
		sse := sse + residual * residual;
	end_for;

	mse := sse / dint_to_lreal(actual_n - 2);

	se_slope := sqrt(mse / ss_x);
	se_intercept := sqrt(mse * (1.0 / dint_to_lreal(actual_n) + m_x * m_x / ss_x));
	{end}
end

{#endif}

