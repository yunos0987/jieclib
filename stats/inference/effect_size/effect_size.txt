(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./stats/inference/effect_size/effect_size.txt -I. -I./vendor/jiecunit/sys -o ./stats/inference/effect_size/effect_size.xml -t omron
 *)
{#ifndef __STATS_INFERENCE_EFFECT_SIZE_EFFECT_SIZE_TXT__}
{#define __STATS_INFERENCE_EFFECT_SIZE_EFFECT_SIZE_TXT__}

{#include <sys.txt>}
{#include <stats/descriptive/mean.txt>}
{#include <stats/descriptive/variance.txt>}

(*{doc Cohen d: 2 グループ間の標準化差
d = (mean_x - mean_y) / pooled_std
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n_x 先頭 n_x 個を使用する。
  デフォルト値: -1
@input n_y 先頭 n_y 個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_cohens_d: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc グループのデータ。}*)
		x: array[*] of lreal;
		(*{doc グループのデータ。}*)
		y: array[*] of lreal;
	end
	var_input
		(*{doc グループの要素数。}*)
		n_x: dint := -1;
		(*{doc グループの要素数。}*)
		n_y: dint := -1;
	end
	var_temp
		actual_nx, actual_ny: dint;
		mean_x, mean_y, var_x, var_y, pooled_std: lreal;
	end
	{st}
	actual_nx := Array_isRegular_lreal(x);
	if (actual_nx = 0) or (n_x > actual_nx) then
		eno := false;
		return;
	end_if;
	if n_x > 0 then
		actual_nx := n_x;
	end_if;
	if actual_nx < 2 then
		eno := false;
		return;
	end_if;

	actual_ny := Array_isRegular_lreal(y);
	if (actual_ny = 0) or (n_y > actual_ny) then
		eno := false;
		return;
	end_if;
	if n_y > 0 then
		actual_ny := n_y;
	end_if;
	if actual_ny < 2 then
		eno := false;
		return;
	end_if;

	mean_x := Stats_mean(data:=x, n:=lreal_to_dint(actual_nx));
	mean_y := Stats_mean(data:=y, n:=lreal_to_dint(actual_ny));
	var_x := Stats_sample_variance(data:=x, n:=lreal_to_dint(actual_nx));
	var_y := Stats_sample_variance(data:=y, n:=lreal_to_dint(actual_ny));

	pooled_std := sqrt(((lreal_to_dint(actual_nx) - 1.0) * var_x + (lreal_to_dint(actual_ny) - 1.0) * var_y) / (lreal_to_dint(actual_nx) + lreal_to_dint(actual_ny) - 2.0));
	if pooled_std < 1e-15 then
		Stats_cohens_d := 0.0;
		return;
	end_if;

	Stats_cohens_d := (mean_x - mean_y) / pooled_std;
	{end}
end

(*{doc Hedges g: Cohen d のバイアス補正
g = d * (1 - 3/(4*(n_x+n_y-2)-1))
@inout x サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@inout y サンプルデータを含む配列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@input n_x 先頭 n_x 個を使用する。
  デフォルト値: -1
@input n_y 先頭 n_y 個を使用する。
  デフォルト値: -1
@return 計算結果。
@error 入力値が不正な場合。}*)
function Stats_hedges_g: lreal
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc グループのデータ。}*)
		x: array[*] of lreal;
		(*{doc グループのデータ。}*)
		y: array[*] of lreal;
	end
	var_input
		(*{doc グループの要素数。}*)
		n_x: dint := -1;
		(*{doc グループの要素数。}*)
		n_y: dint := -1;
	end
	var_temp
		actual_nx, actual_ny: dint;
		d, correction: lreal;
	end
	{st}
	actual_nx := Array_isRegular_lreal(x);
	if (actual_nx = 0) or (n_x > actual_nx) then
		eno := false;
		return;
	end_if;
	if n_x > 0 then
		actual_nx := n_x;
	end_if;
	if actual_nx < 2 then
		eno := false;
		return;
	end_if;

	actual_ny := Array_isRegular_lreal(y);
	if (actual_ny = 0) or (n_y > actual_ny) then
		eno := false;
		return;
	end_if;
	if n_y > 0 then
		actual_ny := n_y;
	end_if;
	if actual_ny < 2 then
		eno := false;
		return;
	end_if;

	d := Stats_cohens_d(x:=x, y:=y, n_x:=lreal_to_dint(actual_nx), n_y:=lreal_to_dint(actual_ny), eno=>eno);
	if not eno then
		return;
	end_if;
	correction := 1.0 - 3.0 / (4.0 * (lreal_to_dint(actual_nx) + lreal_to_dint(actual_ny) - 2.0) - 1.0);
	Stats_hedges_g := d * correction;
	{end}
end

{#endif}

