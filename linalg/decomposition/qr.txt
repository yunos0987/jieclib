(*
 * QR Decomposition
 * $ jiecc ./linalg/decomposition/qr.txt -I. -I./vendor/jiecunit/sys -o ./linalg/decomposition/qr.xml -t omron
 *)
{#ifndef __LINALG_DECOMPOSITION_QR_TXT__}
{#define __LINALG_DECOMPOSITION_QR_TXT__}

{#include <sys.txt>}
{#include <array/array.txt>}
{#include <math/floor.txt>}

(*{doc QR分解。
行列をQR分解し、正規直交行列Qと上三角行列Rを得る。
@in_out a 入力行列。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out q 結果の正規直交行列Q。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@in_out r 結果の上三角行列R。
  正規配列（次元の始点が0で要素数1以上）でなければいけない。
@error 入力行列が正規2次元配列でない場合、aが正方行列でない場合、q/rの行列サイズがaと一致しない場合、または分解途中で列ノルムが0に近くなる場合。}*)
function Matrix_qr_decompose
	_PROLOGUE_OF_FUNCTION_()
	var_in_out
		(*{doc 入力行列。}*)
		a: array[*, *] of lreal;
	end
	var_in_out
		(*{doc 結果の正規直交行列Q。}*)
		q: array[*, *] of lreal;
		(*{doc 結果の上三角行列R。}*)
		r: array[*, *] of lreal;
	end
	var_temp
		i, j, k: dint;
		n: dint;
		a_size, q_size, r_size: dint;
		a_rows, a_cols: dint;
		q_rows, q_cols: dint;
		r_rows, r_cols: dint;
		dot_val, norm_val: lreal;
	end
	{st}
	a_size := Array_isRegular2d_lreal(a);
	q_size := Array_isRegular2d_lreal(q);
	r_size := Array_isRegular2d_lreal(r);
	if (a_size = 0) or (q_size = 0) or (r_size = 0) then
		eno := false;
		return;
	end_if;

	a_rows := upper_bound(a, 1) - lower_bound(a, 1) + 1;
	a_cols := upper_bound(a, 2) - lower_bound(a, 2) + 1;
	q_rows := upper_bound(q, 1) - lower_bound(q, 1) + 1;
	q_cols := upper_bound(q, 2) - lower_bound(q, 2) + 1;
	r_rows := upper_bound(r, 1) - lower_bound(r, 1) + 1;
	r_cols := upper_bound(r, 2) - lower_bound(r, 2) + 1;
	if (a_rows <> a_cols) then
		eno := false;
		return;
	end_if;
	if (q_rows <> a_rows) or (q_cols <> a_cols) then
		eno := false;
		return;
	end_if;
	if (r_rows <> a_rows) or (r_cols <> a_cols) then
		eno := false;
		return;
	end_if;

	n := a_rows;
	for i := 0 to n - 1 by 1 do
		for j := 0 to n - 1 by 1 do
			q[i, j] := a[i, j];
			r[i, j] := 0.0;
		end_for;
	end_for;

	for j := 0 to n - 1 by 1 do
		for i := 0 to j - 1 by 1 do
			dot_val := 0.0;
			for k := 0 to n - 1 by 1 do
				dot_val := dot_val + q[k, i] * q[k, j];
			end_for;
			r[i, j] := dot_val;
			for k := 0 to n - 1 by 1 do
				q[k, j] := q[k, j] - dot_val * q[k, i];
			end_for;
		end_for;
		norm_val := 0.0;
		for k := 0 to n - 1 by 1 do
			norm_val := norm_val + q[k, j] * q[k, j];
		end_for;
		norm_val := sqrt(norm_val);
		if norm_val < 1e-15 then
			eno := false;
			return;
		end_if;
		r[j, j] := norm_val;
		for k := 0 to n - 1 by 1 do
			q[k, j] := q[k, j] / norm_val;
		end_for;
	end_for;
	{end}
end

{#endif}
