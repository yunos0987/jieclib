(*
 * $ cd <JiecLib Project Root>
 * $ jiecc ./array/array.txt -I. -I./vendor/jiecunit/sys -o ./array/array.xml -t omron
 * or
 * $ jiecc ./array/array.txt -I. -I./vendor/jiecunit/sys -o ./array/array.xml -t keyence
 *)
{#ifndef __ARRAY_TXT__}
{#define __ARRAY_TXT__}

{#include <sys.txt>}

{#define Array_size(self) (upper_bound(self, 1) - lower_bound(self, 1) + 1)}
{#define Array_size_lreal(self) Array_size(self)}
{#define Array_size_real(self) Array_size(self)}
{#define Array_size_dint(self) Array_size(self)}

{#if _OMRON}
{#define _DEFINE_ARRAY_IS_REGULAR2D_X_DATATYPE(datatype)
    ${doc 2次元配列の指定次元が正規であるかを判定する。
@input dim 判定する次元。
@return 次元のlower_bound = 0かつサイズ >= 1のとき、要素数を返す。そうでないとき、0を返す。
dimが1または2でない場合、0を返す。$}
    function Array_isRegular2d_x_@@datatype: dint
        _PROLOGUE_OF_FUNCTION_()
        var_in_out
            self: array[*, *] of datatype;
        end
        var_input
            ${doc 判定する次元。$}
            dim: dint;
        end
        var_temp
            lb, ub: dint;
        end
        ${st$}
        if (dim = 1) or (dim = 2) then
            lb := lower_bound(self, dim);
            ub := upper_bound(self, dim);
            if lb = 0 then
                Array_isRegular2d_x_@@datatype := max(ub - lb + 1, 0);
                return;
            end_if;
        end_if;
        Array_isRegular2d_x_@@datatype := 0;
        ${end$}
    end
}
_DEFINE_ARRAY_IS_REGULAR2D_X_DATATYPE(lreal)
_DEFINE_ARRAY_IS_REGULAR2D_X_DATATYPE(dint)
{#undef _DEFINE_ARRAY_IS_REGULAR2D_X_DATATYPE}

{#define _DEFINE_ARRAY_IS_REGULAR2D_DATATYPE(datatype)
    (*${doc 2次元配列が正規配列かどうかを返す。
    両次元のlower_bound = 0かつサイズ >= 1のとき、要素数(行数 * 列数)を返す。そうでないとき、0を返す。$}*)
    function Array_isRegular2d_@@datatype: dint
        _PROLOGUE_OF_FUNCTION_()
        var_in_out
            self: array[*, *] of datatype;
        end
        var_temp
            n1, n2: dint;
        end
        ${st$}
        n1 := Array_isRegular2d_x_@@datatype(self, 1);
        n2 := Array_isRegular2d_x_@@datatype(self, 2);
        Array_isRegular2d_@@datatype := n1 * n2;
        ${end$}
    end
}
_DEFINE_ARRAY_IS_REGULAR2D_DATATYPE(lreal)
_DEFINE_ARRAY_IS_REGULAR2D_DATATYPE(dint)
{#undef _DEFINE_ARRAY_IS_REGULAR2D_DATATYPE}

{#define _DEFINE_ARRAY_IS_REGULAR_DATATYPE(datatype)
    ${doc 1次元配列が正規配列であるかを判定する。
@return lower_bound = 0かつサイズ >= 1のとき、要素数を返す。そうでないとき、0を返す。$}
    function Array_isRegular_@@datatype: dint
        _PROLOGUE_OF_FUNCTION_()
        var_in_out
            self: array[*] of datatype;
        end
        var_temp
            lb, ub: dint;
        end
        ${st$}
        lb := lower_bound(self, 1);
        ub := upper_bound(self, 1);
        if lb = 0 then
            Array_isRegular_@@datatype := max(ub - lb + 1, 0);
        else
            Array_isRegular_@@datatype := 0;
        end_if;
        ${end$}
    end
}
_DEFINE_ARRAY_IS_REGULAR_DATATYPE(lreal)
_DEFINE_ARRAY_IS_REGULAR_DATATYPE(dint)
{#undef _DEFINE_ARRAY_IS_REGULAR_DATATYPE}

{#else}
{#warning Array_isRegular_xxx functions are not supported on Keyence and Mitsubishi PLCs.}
{#define Array_isRegular2d_x_lreal(self) 0}
{#define Array_isRegular2d_x_dint(self) 0}
{#define Array_isRegular2d_lreal(self) 0}
{#define Array_isRegular2d_dint(self) 0}
{#define Array_isRegular_lreal(self) 0}
{#define Array_isRegular_dint(self) 0}
{#endif}

{#include "copy.txt"}
{#include "sort.txt"}

{#endif}
